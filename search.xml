<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fence Repair</title>
    <url>/2020/02/06/Fence-Repair/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=3253" target="_blank" rel="noopener">来源</a></p>
<p>描述：栅栏修补，一共需要n个木条，长度不一，现要求从一个刚好够所有长度的木条上锯开，怎么锯划算，每次的花费是木条长度，如锯开21的木条，需要花费21，求最小花费。</p>
<p>思路：使得较长的木条使用的次数最少即可，那么从短的开始锯，每次计算两根，然后他们的和入队，重新排列。</p>
<p><strong>注意：答案可能溢出，所以用long long int存储。</strong><br>```c++</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn = 20005;
int n,fence[maxn],t;
long long sum = 0;
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    //优先队列的使用
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
    for(int i = 0;i &lt; n;++i){
        scanf(&quot;%d&quot;,&amp;t);
        q.push(t);
    }
    while(q.size() &gt; 1){
        //每次将最短的两根拿出来算
        int a = q.top();
        q.pop();
        int b = q.top();
        q.pop();
        sum += a + b;
        q.push(a+b);
    }
    printf(&quot;%lld&quot;,sum);
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>哈夫曼树</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>P2880 [USACO07JAN]Balanced Lineup G</title>
    <url>/2020/05/19/Balanced%20Lineup/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2880" target="_blank" rel="noopener">传送门</a></p>
<h2 id="倍增做法"><a href="#倍增做法" class="headerlink" title="倍增做法"></a>倍增做法</h2><p>以倍增的做法打个ST表,注意每个变量的意义。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a1,a2;</span><br><span class="line"><span class="keyword">int</span> a[N][<span class="number">22</span>],b[N][<span class="number">22</span>],p[N];<span class="comment">//a[x][y]为(x+1,x+2^y]的最小值,同理，b为最大值，p为原始数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	a1 = p[x],a2 = p[y];</span><br><span class="line">	drp(i,<span class="number">21</span>,<span class="number">0</span>)&#123;    <span class="comment">//以逼近的方式得到最大最小</span></span><br><span class="line">		<span class="keyword">if</span>(x+(<span class="number">1</span>&lt;&lt;i)&lt;=y)&#123;</span><br><span class="line">			a1 = <span class="built_in">min</span>(a1,a[x][i]);</span><br><span class="line">			a2 = <span class="built_in">max</span>(a2,b[x][i]);</span><br><span class="line">			x = (x+(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;       <span class="comment">//初始化</span></span><br><span class="line">		a[i][<span class="number">0</span>]=<span class="built_in">min</span>(p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">		b[i][<span class="number">0</span>]=<span class="built_in">max</span>(p[i],p[i+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">1</span>,<span class="number">21</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;i)&lt;=n;++j)&#123;</span><br><span class="line">			a[j][i]=<span class="built_in">min</span>(a[j][i<span class="number">-1</span>],a[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);<span class="comment">//已更新所有j的i-1,所以可以更新所有j的i</span></span><br><span class="line">			b[j][i]=<span class="built_in">max</span>(b[j][i<span class="number">-1</span>],b[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//极速查询</span></span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">		ST(x,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a2-a1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线段树做法"><a href="#线段树做法" class="headerlink" title="线段树做法"></a>线段树做法</h2><p>显然，每个线段维护的是最大值，最小值，所以采用一个结构体数组表示树<br>显然，这是个静态树，所以只需要build和query，省去了update和lazy tag</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>+<span class="number">5</span>,maxn = <span class="number">1e6</span>+<span class="number">5</span>,minn = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前面提到的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mi,mx;</span><br><span class="line">    Tr()&#123;</span><br><span class="line">        mi = maxn,mx = minn;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,a[N];<span class="comment">//a为初始数组</span></span><br><span class="line">Tr rt[N&lt;&lt;<span class="number">2</span>];<span class="comment">//rt为树上数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>;  <span class="comment">//x的左二子节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>;  <span class="comment">//x的右儿子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;  <span class="comment">//建树</span></span><br><span class="line"><span class="function">Tr <span class="title">query</span><span class="params">(<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>;  <span class="comment">//查询ql,qr上的最大值，最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">        Tr t = query(x,y,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,t.mx-t.mi);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        rt[x].mi = a[l],rt[x].mx = a[l];</span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    build(ls(x),l,mid);</span><br><span class="line">    build(rs(x),mid+<span class="number">1</span>,r);</span><br><span class="line">    rt[x].mi = <span class="built_in">min</span>(rt[ls(x)].mi,rt[rs(x)].mi);</span><br><span class="line">    rt[x].mx = <span class="built_in">max</span>(rt[ls(x)].mx,rt[rs(x)].mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tr <span class="title">query</span><span class="params">(<span class="keyword">int</span> ql,<span class="keyword">int</span> qr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    Tr res;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ql&amp;&amp;r&lt;=qr)&#123;</span><br><span class="line">        res.mi = rt[p].mi;</span><br><span class="line">        res.mx = rt[p].mx;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql&lt;=mid)&#123;</span><br><span class="line">        Tr t1 = query(ql,qr,l,mid,ls(p));</span><br><span class="line">        res.mi = <span class="built_in">min</span>(res.mi,t1.mi),res.mx=<span class="built_in">max</span>(res.mx,t1.mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)&#123;</span><br><span class="line">        Tr t1 = query(ql,qr,mid + <span class="number">1</span>,r,rs(p));</span><br><span class="line">        res.mi = <span class="built_in">min</span>(res.mi,t1.mi),res.mx=<span class="built_in">max</span>(res.mx,t1.mx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>4 Values whose Sum is 0</title>
    <url>/2020/05/22/4-Values-whose-Sum-is-0/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=2785" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>描述：给出4个数组，从每个数组挑出一个数，使得总和为0</li>
<li>思路：将其中两个数组组合，剩下两个数组遍历，复杂度$O(nlogn)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e3</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],c[N],d[N],CD[N*N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	rep(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;a[i],&amp;b[i],&amp;c[i],&amp;d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		rep(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">			CD[i*n+j]=c[i]+d[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(CD,CD+n*n);</span><br><span class="line">	rep(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		rep(j,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> cd = -(a[i]+b[j]);</span><br><span class="line">			ans += upper_bound(CD,CD+n*n,cd)-lower_bound(CD,CD+n*n,cd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2-SAT</title>
    <url>/2020/05/29/2-SAT/</url>
    <content><![CDATA[<p>(<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)[https://en.wikipedia.org/wiki/Boolean_satisfiability_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Boolean_satisfiability_problem)[https://en.wikipedia.org/wiki/Boolean_satisfiability_problem</a>]</p>
<p>SAT(satisfiability):一般形式为k-适定性问题，简称 k-SAT,k&gt;2,是np完全的，一般讨论2-SAT问题<br>通俗的讲，就是给出若干变量$a_i$，以及若干条件，$a_i and / or / xor a_j = 0/1$，求满足条件的a数组</p>
<p><a href="https://www.luogu.com.cn/problem/P4782" target="_blank" rel="noopener">模板题</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,cnt,tot,top,r;</span><br><span class="line"><span class="keyword">int</span> dfn[N],low[N],id[N],stac[N],head[N],vis[N],exi[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[++cnt].nxt = head[a];</span><br><span class="line">    e[cnt].from = a;</span><br><span class="line">    e[cnt].to = b;</span><br><span class="line">    head[a] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++tot;</span><br><span class="line">    vis[x] = <span class="number">1</span>;stac[++top] = x;exi[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[e[i].to])&#123;</span><br><span class="line">            tarjan(e[i].to);</span><br><span class="line">            low[x] = MIN(low[x],low[e[i].to]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exi[e[i].to])&#123;</span><br><span class="line">            low[x] = MIN(low[x],low[e[i].to]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        ++r;                    <span class="comment">//拓扑序在此</span></span><br><span class="line">        <span class="keyword">while</span>(t = stac[top--])&#123;</span><br><span class="line">            id[t] = r;</span><br><span class="line">            exi[t] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(t==x)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a,b,c,d;m;m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;a,&amp;c,&amp;b,&amp;d);</span><br><span class="line">        <span class="comment">//核心代码</span></span><br><span class="line">        <span class="comment">//将逻辑转换为有向边，即a为!c状态，那么b肯定为d状态</span></span><br><span class="line">        <span class="comment">//也就是说，这个图是满足所有逻辑的，取一个拓扑序就是答案了</span></span><br><span class="line">        <span class="comment">//至于为什么要取拓扑序，是因为这个图是有前后逻辑的，你的后面的并不能推到前面</span></span><br><span class="line">        <span class="comment">//建图也是根据逻辑建的</span></span><br><span class="line">        <span class="comment">//而且证明图是可行的之后，两个值只能取一个，那么就是前面那个</span></span><br><span class="line">        <span class="keyword">if</span>(c&amp;&amp;d)&#123;</span><br><span class="line">            add(b+n,a);</span><br><span class="line">            add(a+n,b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c&amp;&amp;!d)&#123;</span><br><span class="line">            add(a+n,b+n);</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!c&amp;&amp;d)&#123;</span><br><span class="line">            add(a,b);</span><br><span class="line">            add(b+n,a+n);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            add(a,b+n);</span><br><span class="line">            add(b,a+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n*<span class="number">2</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            tarjan(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(id[i]==id[i+n])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"POSSIBLE"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,id[i]&gt;id[i+n]);    <span class="comment">//前面以及标号拓扑序，这里直接取拓扑序在前面的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Commando War</title>
    <url>/2020/02/05/Commando-War/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/UVA-11729" target="_blank" rel="noopener"><strong>描述</strong></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">peo</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line">peo p[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(peo p1,peo p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.j &gt; p2.j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,id = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) == <span class="number">1</span> &amp;&amp; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p[i].b,&amp;p[i].j);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		sort(p,p+n,cmp);</span><br><span class="line"> 		<span class="keyword">int</span> cost = <span class="number">0</span>,s = <span class="number">0</span>;</span><br><span class="line"> 		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line"> 			<span class="comment">//发布任务的时间是固定的</span></span><br><span class="line"> 			s += p[i].b;		</span><br><span class="line"> 			<span class="comment">//每次比较答案和固定发布时间加上最后一次的执行任务的时间的大小</span></span><br><span class="line"> 			cost = <span class="built_in">max</span>(cost,s + p[i].j);	</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,id++,cost);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>FBI树</title>
    <url>/2020/02/12/FBI%E6%A0%91/</url>
    <content><![CDATA[<p><strong>原题链接：</strong><a href="https://www.luogu.com.cn/problem/P1087" target="_blank" rel="noopener">传送门</a></p>
<p><strong>思路：</strong><br>递归回溯<br>如果l &lt; r，那么用二分，返回左子树和右子树的值，处理后输出<br>如果l == r，根据数字0或1输出并返回字母</p>
<p><strong>代码：</strong></p>
<p>```c++</p>
<pre><code>#include&lt;cstdio&gt;
const int maxn = 1&lt;&lt;10 + 2;
char arr[maxn];
char ef(int l,int r){
    if(l&lt;r){
        int t = l + (r - l)/2;
        char a = ef(l,t);//左子树的返回值
        char b = ef(t+1,r);//右子树的返回值
        if(a == &#39;B&#39;&amp;&amp; b==&#39;B&#39;){
            putchar(&#39;B&#39;);
            return &#39;B&#39;;
        }else if(a == &#39;I&#39; &amp;&amp; b ==&#39;I&#39;){
            putchar(&#39;I&#39;);
            return &#39;I&#39;;
        }else {
            putchar(&#39;F&#39;);
            return &#39;F&#39;;
        }
    }
    //l == r时的处理
    if(arr[l] == &#39;0&#39;){
        putchar(&#39;B&#39;);
        return &#39;B&#39;;
    }else{
    putchar(&#39;I&#39;);
    return &#39;I&#39;;
    }
}
int main(){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    scanf(&quot;%s&quot;,arr);
    ef(0,(1&lt;&lt;n) - 1);
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP字符串匹配</title>
    <url>/2020/05/13/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<ul>
<li>介绍：字符串s1,s2,求s2在s1中所有出现的位置</li>
<li>思路：<ul>
<li>预处理kmp数组，kmp[i]表示第i位的前后缀最大的相同位数</li>
<li>遍历文本串</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N],b[N];   <span class="comment">//a是文本串，b是模式串</span></span><br><span class="line"><span class="keyword">int</span> kmp[N],la,lb,cnt,ans[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    la=<span class="built_in">strlen</span>(a+<span class="number">1</span>),lb=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用自身匹配自身</span></span><br><span class="line">    rep(i,<span class="number">2</span>,lb)&#123;     </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="number">1</span>])  <span class="comment">//j表示模式串中已经匹配的前缀和后缀位数</span></span><br><span class="line">            j=kmp[j];    </span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i])j++;    </span><br><span class="line">        kmp[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">    init();</span><br><span class="line">    rep(i,<span class="number">1</span>,la)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt&amp;&amp;a[i]!=b[cnt+<span class="number">1</span>])cnt=kmp[cnt]; <span class="comment">//无法匹配时，向kmp数组询问</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[cnt+<span class="number">1</span>])++cnt;</span><br><span class="line">        <span class="keyword">if</span>(cnt==lb)&#123;cnt=kmp[cnt],ans[++tot]=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,tot)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]-lb+<span class="number">1</span>); <span class="comment">//输出每一个匹配的地点</span></span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,lb)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,kmp[i]);   <span class="comment">//输出kmp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Frogger</title>
    <url>/2020/02/06/Frogger/</url>
    <content><![CDATA[<p><strong>原题链接：</strong><a href="https://vjudge.net/problem/POJ-2253" target="_blank" rel="noopener">传送门</a><br><strong>思路：</strong>由于数据量较小，直接采用Floyd的改进算法，O(n<em>n</em>n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],id = <span class="number">1</span>,n,a,b;</span><br><span class="line"><span class="keyword">double</span> s[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">			s[i][i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= n;++j)&#123;</span><br><span class="line">				s[j][i] = s[i][j] = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(<span class="built_in">abs</span>(x[i]-x[j])*<span class="number">1.0</span>,<span class="number">2</span>)+<span class="built_in">pow</span>(<span class="built_in">abs</span>(y[i] - y[j])*<span class="number">1.0</span>,<span class="number">2</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;++k)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j)&#123;</span><br><span class="line">					s[i][j] = <span class="built_in">min</span>(s[i][j],<span class="built_in">max</span>(s[i][k],s[k][j]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Scenario #%d\nFrog Distance = %.3lf\n\n"</span>,id++,s[<span class="number">1</span>][<span class="number">2</span>]);;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Maya Calendar</title>
    <url>/2020/01/29/Maya%20Calendar/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=1008" target="_blank" rel="noopener">Description</a><br>解题思路：<br>1.先把固有的数据放入char数组中并预定义其他要用的变量<br>2.用scanf和printf规范的输入，大大减小复杂度<br>3.注意每月和每年的最后一天，除余为0，那么实际上应该是最大值，如果是年份除余为0，还得减一。<br>下面是代码，16ms。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//预定义</span></span><br><span class="line"><span class="keyword">char</span> hname[<span class="number">19</span>][<span class="number">10</span>] = &#123;<span class="string">"pop"</span>, <span class="string">"no"</span>, <span class="string">"zip"</span>, <span class="string">"zotz"</span>, <span class="string">"tzec"</span>, <span class="string">"xul"</span>, <span class="string">"yoxkin"</span>, <span class="string">"mol"</span>, <span class="string">"chen"</span></span><br><span class="line">, <span class="string">"yax"</span>, <span class="string">"zac"</span>, <span class="string">"ceh"</span>, <span class="string">"mac"</span>,<span class="string">"kankin"</span>, <span class="string">"muan"</span>,<span class="string">"pax"</span>,<span class="string">"koyab"</span>, <span class="string">"cumhu"</span>,<span class="string">"uayet"</span>&#125;;<span class="comment">//月 </span></span><br><span class="line"><span class="keyword">char</span> tname[<span class="number">20</span>][<span class="number">10</span>] = &#123;<span class="string">"imix"</span>, <span class="string">"ik"</span>, <span class="string">"akbal"</span>, <span class="string">"kan"</span>, <span class="string">"chicchan"</span>, <span class="string">"cimi"</span>, <span class="string">"manik"</span>, <span class="string">"lamat"</span>, <span class="string">"muluk"</span>,</span><br><span class="line"> <span class="string">"ok"</span>, <span class="string">"chuen"</span>, <span class="string">"eb"</span>, <span class="string">"ben"</span>, <span class="string">"ix"</span>, <span class="string">"mem"</span>, <span class="string">"cib"</span>, <span class="string">"caban"</span>, <span class="string">"eznab"</span>, <span class="string">"canac"</span>, <span class="string">"ahau"</span> &#125;;<span class="comment">//日 </span></span><br><span class="line"><span class="keyword">int</span> yy,dd,n,pos,days,mon;</span><br><span class="line"><span class="keyword">char</span> mm[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d. %s %d"</span>,&amp;dd,mm,&amp;yy);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">19</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(mm,hname[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">				mon = j;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		days = dd + <span class="number">1</span> + yy*<span class="number">365</span> + mon * <span class="number">20</span>;</span><br><span class="line">		yy = days / <span class="number">260</span>;</span><br><span class="line">		days %= <span class="number">260</span>;</span><br><span class="line">		<span class="keyword">if</span>(days == <span class="number">0</span>)&#123;</span><br><span class="line">			yy--;</span><br><span class="line">			days = <span class="number">260</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dd = days % <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">if</span>(dd == <span class="number">0</span>)dd = <span class="number">13</span>;</span><br><span class="line">		mon = days % <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">if</span>(mon == <span class="number">0</span>)mon = <span class="number">20</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %s %d\n"</span>,dd,tname[mon - <span class="number">1</span>],yy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>简单数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>BootStrap框架</title>
    <url>/2020/06/11/BootStrap%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ul>
<li>概念：前端开发框架，开发人员可在框架基础上进一步开发</li>
<li>好处<ul>
<li>定义了很多css样式和js插件，得到丰富的页面效果</li>
<li>响应式布局，兼容不同分辨率的设备</li>
</ul>
</li>
<li>快速入门<ul>
<li>下载bootstrap</li>
<li>项目中引入，复制到项目当前目录</li>
<li>创建html页面，引入必要的资源文件</li>
</ul>
</li>
<li>响应式布局<ul>
<li>同一套页面可以兼容不同分辨率的设备</li>
<li>实现：依赖于栅格系统，将一行分成12个格子,然后可以让元素占得格子数量进行改变</li>
<li>步骤<ul>
<li>定义容器，相当于table<ul>
<li>container，比起container-fluid，会有留白</li>
<li>container-fluid：每种设备都是100%宽度</li>
</ul>
</li>
<li>定义行，想当于tr，row</li>
<li>定义元素，指定该元素在不同的设备上所占的各自数目。样式：col-设备代号-格子数目<ul>
<li>设备代号<ul>
<li>xs：超小屏幕 手机 &lt;768px 例：col-xs-12</li>
<li>sm：小屏幕 平板 &gt;=768px</li>
<li>md：桌面显示器 &gt;=992px</li>
<li>lg：大屏幕 &gt;=1200px</li>
</ul>
</li>
</ul>
</li>
<li>注意<ul>
<li>一行如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容</li>
<li>如果设备宽度小于设备代号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>CSS样式和js插件<ul>
<li>属于拿来就用，不要想太多，毕竟是前端的东西</li>
<li>全局css样式<ul>
<li>按钮：class=”btn btn-default”</li>
<li>图片<ul>
<li>class=”img-resopnsive”调成响应式图片</li>
<li>图片形状：class = “img-rounded”…</li>
</ul>
</li>
<li>表格：设置form的表格<ul>
<li>.table-striped：条纹装表格</li>
<li>.table-bordered：边框状表格</li>
<li>.table-hover：鼠标悬停</li>
<li>.table-condensed：紧缩表格</li>
<li>状态类：可以通过状态类为行或单元格设置颜色</li>
</ul>
</li>
<li>表单<ul>
<li>form-control</li>
</ul>
</li>
</ul>
</li>
<li>组件<ul>
<li>导航条:类似淘宝的下拉条幅</li>
<li>分页条</li>
</ul>
</li>
<li>轮播图</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>Lingo</title>
    <url>/2020/07/09/Lingo/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<p>LINGO is a comprehensive tool designed to make building and solving Linear, Nonlinear (convex &amp; nonconvex/Global), Quadratic, Quadratically Constrained, Second Order Cone, Semi-Definite, Stochastic, and Integer optimization models faster, easier and more efficient. ——官方总体介绍</p>
</blockquote>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2>]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title>Lake Counting</title>
    <url>/2020/02/05/Lake-Counting/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/problem/POJ-2386" target="_blank" rel="noopener">描述</a></p>
<p>```c++</p>
<pre><code>    #include&lt;cstdio&gt;
    using namespace std;
    const int maxn = 105;
    char p[maxn][maxn];
    int n,m,ans = 0;
    void dfs(int a,int b){
        p[a][b] = &#39;.&#39;;
        for(int i = -1;i &lt;= 1;++i){
            for(int j = -1;j &lt;= 1;++j){
                int x = a + i;
                int y = b + j;
                if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; p[x][y] == &#39;W&#39;){
                    dfs(x,y);
                }
            }
        }
    }
    int main(){
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i = 0;i &lt; n;++i){
            scanf(&quot;%s&quot;,p[i]);
        }
        for(int i = 0;i &lt; n;++i){
            for(int j = 0;j &lt; m;++j){
                if(p[i][j] == &#39;W&#39;){ 
                    ans++;
                    dfs(i,j);
                } 
            }
        }
        printf(&quot;%d&quot;,ans);
        return 0;
    }
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3279</title>
    <url>/2020/05/22/POJ-3279/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=3279" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>描述：n*m个格子，每个格子两个颜色，改变一个格子会同时改变它周围4个格子的颜色，求最少操作数使得所有格子颜色一致</li>
<li>思路：按字典序全排列第一行的改变，1为改变，0为不变，然后在下一行判断上一格的颜色，如果需要改变，那就翻转这一格，这样，所有前面的格子都是一致的，最后只要判断最后一行的颜色。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(A,B)(A&lt;B?B:A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(A,B)(A&lt;B?A:B)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uit unsigned int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>,R = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N][N],flip[N][N],opt[N][N],ans=R;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取j，k格子的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcol</span><span class="params">(<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f = a[j][k];</span><br><span class="line">	rep(i,<span class="number">0</span>,<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = dx[i]+j,y = dy[i]+k;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m)&#123;</span><br><span class="line">			f += flip[x][y];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取翻转的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	rep(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">		rep(k,<span class="number">1</span>,m)&#123;</span><br><span class="line">			res += flip[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出翻转的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//按第一层的字典序进行遍历，以整数代替一个集合</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(flip,<span class="number">0</span>,<span class="keyword">sizeof</span>(flip));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;++j)&#123;</span><br><span class="line">			flip[<span class="number">1</span>][m-j]=i&gt;&gt;j&amp;<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(j,<span class="number">2</span>,n)&#123;</span><br><span class="line">			rep(k,<span class="number">1</span>,m)&#123;</span><br><span class="line">				<span class="keyword">if</span>(getcol(j<span class="number">-1</span>,k))&#123;</span><br><span class="line">					flip[j][k]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> fg = <span class="number">1</span>;</span><br><span class="line">		rep(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">			<span class="keyword">if</span>(getcol(n,j))&#123;</span><br><span class="line">				fg = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(fg)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = getf();</span><br><span class="line">			<span class="keyword">if</span>(t&lt;ans)&#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(opt,flip,<span class="keyword">sizeof</span>(flip));</span><br><span class="line">				ans = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans!=R)output();</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;</span><br><span class="line">	rep(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,opt[j][<span class="number">1</span>]);</span><br><span class="line">		rep(k,<span class="number">2</span>,m)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d"</span>,opt[j][k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>开关问题</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2020/06/21/Servlet/</url>
    <content><![CDATA[<ul>
<li>概念：运行在服务器端的小程序</li>
<li>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</li>
<li>将来我们自定义一个类，实现Servlet接口，复写方法。</li>
</ul>
<ul>
<li>快速入门：</li>
</ul>
<ol>
<li>创建JavaEE项目</li>
<li>定义一个类，实现Servlet接口</li>
</ol>
<ul>
<li>public class ServletDemo1 implements Servlet</li>
</ul>
<ol>
<li>实现接口中的抽象方法</li>
<li>配置Servlet<br>在web.xml中配置：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>执行原理：</li>
</ul>
<ol>
<li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li>
<li>查找web.xml文件，是否有对应的&lt; url-pattern &gt;标签体内容。</li>
<li>如果有，则在找到对应的&lt; servlet-class &gt;全类名</li>
<li>tomcat会将字节码文件加载进内存，并且创建其对象</li>
<li>调用其方法</li>
</ol>
<ul>
<li>Servlet中的生命周期方法：</li>
</ul>
<ol>
<li>被创建：执行init方法，只执行一次</li>
</ol>
<ul>
<li>Servlet什么时候被创建？<ul>
<li>默认情况下，第一次被访问时，Servlet被创建</li>
<li>可以配置执行Servlet的创建时机。<ul>
<li>在&lt; servlet &gt;标签下配置<ol>
<li>第一次被访问时，创建<pre><code>   * &lt;load-on-startup&gt;的值为负数
</code></pre></li>
<li>在服务器启动时，创建<ul>
<li>&lt; load-on-startup &gt;的值为0或正整数</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的<ul>
<li>多个用户同时访问时，可能存在线程安全问题。</li>
<li>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</li>
</ul>
</li>
</ul>
<ol>
<li>提供服务：执行service方法，执行多次</li>
</ol>
<ul>
<li>每次访问Servlet时，Service方法都会被调用一次。</li>
</ul>
<ol>
<li>被销毁：执行destroy方法，只执行一次</li>
</ol>
<ul>
<li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li>
<li>只有服务器正常关闭时，才会执行destroy方法。</li>
<li><p>destroy方法在Servlet被销毁之前执行，一般用于释放资源</p>
</li>
<li><p>Servlet3.0：</p>
</li>
<li>好处：</li>
<li><p>支持注解配置。可以不需要web.xml了。</p>
</li>
<li><p>步骤：</p>
</li>
</ul>
<ol>
<li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li>
<li>定义一个类，实现Servlet接口</li>
<li>复写方法</li>
<li>在类上使用@WebServlet注解，进行配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"资源路径"</span>)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;<span class="comment">//相当于&lt;Servlet-name&gt;</span></span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//代表urlPatterns()属性配置</span></span><br><span class="line"></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//相当于&lt;url-pattern&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;<span class="comment">//相当于&lt;load-on-startup&gt;</span></span><br><span class="line"></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">displayName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>Tarjan 缩点</title>
    <url>/2020/05/08/Tarjan-%E7%BC%A9%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>简介：Tarjan算法可以把所有的强连通子图找出来</li>
<li>算法步骤：</li>
</ul>
]]></content>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>Meteor Shower</title>
    <url>/2020/02/16/Meteor-Shower/</url>
    <content><![CDATA[<p>原题链接：<a href="http://poj.org/problem?id=3669" target="_blank" rel="noopener">传送门</a></p>
<p>题意：贝西在（0，0）点出发，路上有流星雨，给出流星雨的地点和降落时间，并且流星雨会摧毁该点及上下左右四个方块，每次贝西只能在1s内水平或垂直移动一个距离，求贝西是否移动到安全地点。</p>
<p>思路：建一个数组map[][]为图的点，记录降落时间，mark[][]为是否访问过的点，bfs遍历即可。</p>
<p>```c++</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
using namespace std;
int map[310][310];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int mark[310][310];
struct node
{
    int x,y,step;
}temp,a;
bool operator &lt; (const node &amp;a,const node &amp;b)
{
    return a.step&gt;b.step;
} 

int min(int a,int b)
{
    return a&gt;b?b:a;
}

void bfs()
{
    int i;
    memset(mark,0,sizeof(mark));
    priority_queue&lt;node&gt;q;
    a.x=0;
    a.y=0;
    a.step=0;
    q.push(a);
    mark[0][0]=1;
    while(!q.empty())
    {
        a=q.top();
        q.pop();
        if(map[a.x][a.y]==-1)
        {
            printf(&quot;%d\n&quot;,a.step);
            return ;
        }
        for(i=0;i&lt;4;++i)
        {
            temp.x=a.x+dir[i][0];
            temp.y=a.y+dir[i][1];
            temp.step=a.step+1;
            if(temp.x&gt;=0&amp;&amp;temp.y&gt;=0&amp;&amp;(map[temp.x][temp.y]==-1||map[temp.x][temp.y]&gt;temp.step))
            {
                if(!mark[temp.x][temp.y])
                q.push(temp);
                mark[temp.x][temp.y]=1;
            }
        }
    }
    printf(&quot;-1\n&quot;);
}



int main()
{
    int n,x,y,t,i,j;
    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)
    {
        memset(map,-1,sizeof(map));
        for(i=0;i&lt;n;++i)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;t);
            if(map[x][y]==-1)//判断是否受过撞击时间的更新 
                map[x][y]=t;
            else
                map[x][y]=min(map[x][y],t);//受过撞击后的点不能再走了 
            for(j=0;j&lt;4;++j)
            {
                int nx=x+dir[j][0];
                int ny=y+dir[j][1];
                if(nx&gt;=0&amp;&amp;ny&gt;=0)
                {
                    if(map[nx][ny]==-1)
                        map[nx][ny]=t;
                    else
                        map[nx][ny]=min(t,map[nx][ny]); 
                }
            }
        }
        bfs();
    }
    return 0;

}
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>P1378 油滴扩展</title>
    <url>/2020/02/14/P1378-%E6%B2%B9%E6%BB%B4%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1378" target="_blank" rel="noopener">传送门</a></p>
<p>描述：n个油滴扩展，碰到边界或者其他油滴即停止</p>
<p>思路：利用c++ STL自带的枚举函数，对所有点出现的顺序一一枚举，然后每次计算累加油滴的面积，即可AC</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265358979323846</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//枚举N个点，对每个点累加面积</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">int</span> id,x,y;<span class="keyword">double</span> r;&#125;p[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,t[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>,all;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2)</span></span>&#123;<span class="keyword">return</span> p1.id &lt; p2.id;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;t[<span class="number">0</span>],&amp;t[<span class="number">1</span>],&amp;t[<span class="number">2</span>],&amp;t[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p[i].x,&amp;p[i].y),p[i].id = i;</span><br><span class="line">    all = <span class="built_in">abs</span>((t[<span class="number">0</span>] - t[<span class="number">2</span>]) * (t[<span class="number">1</span>] - t[<span class="number">3</span>]));</span><br><span class="line">    <span class="comment">//枚举</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//一个个的计算</span></span><br><span class="line">        <span class="keyword">double</span> st = <span class="number">0</span>,r = __INT_MAX__;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">            r = <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">abs</span>(p[i].x - t[<span class="number">0</span>]),<span class="built_in">abs</span>(p[i].x - t[<span class="number">2</span>])),<span class="built_in">min</span>(<span class="built_in">abs</span>(p[i].y - t[<span class="number">1</span>]),<span class="built_in">abs</span>(p[i].y - t[<span class="number">3</span>])));<span class="comment">//获取由边界得到的当前点i的最小r</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;++j)&#123;       <span class="comment">//更新r</span></span><br><span class="line">                r = <span class="built_in">min</span>(r,<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p[i].x - p[j].x,<span class="number">2</span>) + <span class="built_in">pow</span>(p[i].y - p[j].y,<span class="number">2</span>)) - p[j].r);</span><br><span class="line">                <span class="keyword">if</span>(r &lt;= <span class="number">0</span>)&#123;r = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p[i].r = r;</span><br><span class="line">            st += r*r;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,st);</span><br><span class="line">    &#125;<span class="keyword">while</span>(next_permutation(p,p+n,cmp));</span><br><span class="line">    ans = ans * PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(<span class="keyword">int</span>)(all - ans + <span class="number">0.5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title>apt and apt-get</title>
    <url>/2020/05/28/apt-and-apt-get/</url>
    <content><![CDATA[<p><a href="https://itsfoss.com/apt-vs-apt-get-difference/" target="_blank" rel="noopener">source artical</a></p>
<p>apt简而言之，就是apt-get和apt-cache中最常使用的命令的集合，对一般用户来说，命令足够用了，但是，apt并不总是向后兼容apt-get，apt-get依旧有它自己的特色</p>
<p>因此，推荐使用apt而不是apt-get，除非需要用到apt-get的一些独有的功能。</p>
<p>附：清华镜像源</p>
<p># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br># deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br># deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-updates main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br># deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-backports main restricted universe multiverse<br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse<br># deb-src <a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a> bionic-security main restricted universe multiverse</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2020/01/31/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>一、为什么要学习数据库
二、数据库的相关概念      
    DBMS、DB、SQL
三、数据库存储数据的特点
四、初始MySQL
    MySQL产品的介绍        
    MySQL产品的安装          ★        
    MySQL服务的启动和停止     ★
    MySQL服务的登录和退出     ★      
    MySQL的常见命令和语法规范      
五、DQL语言的学习   ★              
    基础查询        ★             
    条件查询         ★            
    排序查询         ★                
    常见函数        ★               
    分组函数        ★              
    分组查询           ★            
    连接查询         ★            
    子查询       √                  
    分页查询       ★              
    union联合查询    √            

六、DML语言的学习    ★             
    插入语句                        
    修改语句                        
    删除语句                        
七、DDL语言的学习  
    库和表的管理     √                
    常见数据类型介绍  √          
    常见约束        √            
八、TCL语言的学习
    事务和事务处理                 
九、视图的讲解           √
十、变量                      
十一、存储过程和函数   
十二、流程控制结构       
</code></pre><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><pre><code>1.持久化数据到本地
2.可以实现结构化查询，方便管理
</code></pre><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><pre><code>1、DB：数据库，保存一组有组织的数据的容器
2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据
3、SQL:结构化查询语言，用于和DBMS通信的语言
</code></pre><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中
2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。
3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。
4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”
5、表中的数据是按行存储的，每一行类似于java中的“对象”。
</code></pre><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>方式一：计算机——右击管理——服务
方式二：通过管理员身份运行
net start 服务名（启动服务）
net stop 服务名（停止服务）
</code></pre><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>方式一：通过mysql自带的客户端
只限于root用户

方式二：通过windows自带的客户端
登录：
mysql 【-h主机名 -P端口号 】-u用户名 -p密码

退出：
exit或ctrl+C
</code></pre><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库
show databases;
2.打开指定的库
use 库名
3.查看当前库的所有表
show tables;
4.查看其它库的所有表
show tables from 库名;
5.创建表
create table 表名(
    列名 列类型,
    列名 列类型，
    。。。
);
6.查看表结构
desc 表名;
7.查看服务器的版本
方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version
或
mysql --V
</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写
2.每条命令最好用分号结尾
3.每条命令根据需要，可以进行缩进 或换行
4.注释
    单行注释：#注释文字
    单行注释：-- 注释文字
    多行注释：/* 注释文字  */
</code></pre><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言
    select 
DML(Data Manipulate Language):数据操作语言
    insert 、update、delete
DDL（Data Define Languge）：数据定义语言
    create、drop、alter
TCL（Transaction Control Language）：事务控制语言
    commit、rollback
</code></pre><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库
use 库名； 打开指定 的库
show tables ; 显示库中的所有表
show tables from 库名;显示指定库中的所有表
create table 表名(
    字段名 字段类型,    
    字段名 字段类型
); 创建表
desc 表名; 查看指定表的结构
select * from 表名;显示表中的所有数据
</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><pre><code>语法：
SELECT 要查询的东西
【FROM 表名】;
类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数
</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据
语法：
select 
    要查询的字段|表达式|常量值|函数
from 
    表
where 
    条件 ;
分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;
二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000
逻辑运算符：
    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true
三、模糊查询
示例：last_name like &#39;a%&#39;
</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】
</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><pre><code>一、单行函数
1、字符函数
    concat拼接
    substr截取子串
    upper转换成大写
    lower转换成小写
    trim去前后指定的空格和字符
    ltrim去左边空格
    rtrim去右边空格
    replace替换
    lpad左填充
    rpad右填充
    instr返回子串第一次出现的索引
    length 获取字节个数

2、数学函数
    round 四舍五入
    rand 随机数
    floor向下取整
    ceil向上取整
    mod取余
    truncate截断
3、日期函数
    now当前系统日期+时间
    curdate当前系统日期
    curtime当前系统时间
    str_to_date 将字符转换成日期
    date_format将日期转换成字符
4、流程控制函数
    if 处理双分支
    case语句 处理多分支
        情况1：处理等值判断
        情况2：处理条件判断

5、其他函数
    version版本
    database当前库
    user当前连接用户
二、分组函数
    sum 求和
    max 最大值
    min 最小值
    avg 平均值
    count 计数
    特点：
    1、以上五个分组函数都忽略null值，除了count(*)
    2、sum和avg一般用于处理数值型
        max、min、count可以处理任何数据类型
    3、都可以搭配distinct使用，用于统计去重后的结果
    4、count的参数可以支持：
        字段、*、常量值，一般放1
       建议使用 count(*)
</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><pre><code>语法：
select 查询的字段，分组函数
from 表
group by 分组的字段
特点：
1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段
3、分组筛选
        针对的表    位置            关键字
分组前筛选：    原始表        group by的前面        where
分组后筛选：    分组后的结果集    group by的后面        having
4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名
</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件
</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p>
<pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能
</code></pre><p>二、sql99语法：通过join关键字实现连接</p>
<pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！
</code></pre><p>三、自连接</p>
<p>案例：查询员工名和直接上级的名称</p>
<p>sql99</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m ON e.`manager_id`=m.`employee_id`;
</code></pre><p>sql92</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;
</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询
</code></pre><p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空

② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替
</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句
</code></pre><p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;
</code></pre><p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page
</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：</p>
<pre><code>union 联合、合并
</code></pre><p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】
</code></pre><p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重
</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：</p>
<pre><code>insert into 表名(字段名，...)
values(值1，...);
</code></pre><p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致
</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p>
<pre><code>update 表名 set 字段=新值,字段=新值
【where 条件】
</code></pre><p>修改多表语法：</p>
<pre><code>update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件
</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p>
<p>单表的删除： ★</p>
<pre><code>delete from 表名 【where 筛选条件】
</code></pre><p>多表的删除：</p>
<pre><code>delete 别名1，别名2
from 表1 别名1，表2 别名2
where 连接条件
and 筛选条件;
</code></pre><p>方式2：truncate语句</p>
<pre><code>truncate table 表名
</code></pre><p>两种方式的区别【面试题】</p>
<pre><code>#1.truncate不能加where条件，而delete可以加where条件

#2.truncate的效率高一丢丢

#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始

#4.truncate删除不能回滚，delete删除可以回滚
</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p>
<pre><code>一、创建库
create database 库名
二、删除库
drop database 库名
</code></pre><p>表的管理：</p>
<pre><code>#1.创建表

CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME


);

DESC studentinfo;
#2.修改表 alter
语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

#①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

#②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;
#③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

#④添加字段

ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;
#⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;


#3.删除表

DROP TABLE [IF EXISTS] studentinfo;
</code></pre><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：

小数：
    浮点型
    定点型
字符型：
日期型：
Blob类型：
</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY
</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态
</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>（ACID）
原子性：要么都执行，要么都回滚
一致性：保证数据的状态操作前和操作后保持一致
隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰
持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改
</code></pre><p>相关步骤：</p>
<pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务
</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p>
<pre><code>比如
insert、update、delete语句本身就是一个事务
</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p>
<pre><code>    1、开启事务
    取消自动提交事务的功能

    2、编写事务的一组逻辑操作单元（多条sql语句）
    insert
    update
    delete

    3、提交事务或回滚事务
</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点
</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p>
<pre><code>当多个事务同时操作同一个数据库的相同数据时
</code></pre><p>事务的并发问题有哪些？</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据
</code></pre><p>如何避免事务的并发问题？</p>
<pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED
2、READ COMMITTED 可以避免脏读
3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE可以避免脏读、不可重复读和幻读
</code></pre><p>设置隔离级别：</p>
<pre><code>set session|global  transaction isolation level 隔离级别名;
</code></pre><p>查看隔离级别：</p>
<pre><code>select @@tx_isolation;
</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p>
<p>视图和表的区别：</p>
<pre><code>    使用方式    占用物理空间

视图    完全相同    不占用，仅仅保存的是sql逻辑

表    完全相同    占用
</code></pre><p>视图的好处：</p>
<pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性
</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><pre><code>语法：
CREATE VIEW  视图名
AS
查询语句;
</code></pre><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★

SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);

3、修改视图的数据

UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;


4、删除视图的数据
DELETE FROM my_v4;
</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><pre><code>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all
常量视图
Select中包含子查询
join
from一个不能更新的视图
where子句的子查询引用了from子句中的表
</code></pre><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>#方式一：
CREATE OR REPLACE VIEW test_v7
AS
SELECT last_name FROM employees
WHERE employee_id&gt;100;

#方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;
</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;
</code></pre><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><pre><code>DESC test_v7;
SHOW CREATE VIEW test_v7;
</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p>
<pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数
</code></pre><p>分类：</p>
<pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个
</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p>
<pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end
</code></pre><p>类似于方法：</p>
<pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){

    方法体;
}
</code></pre><p>注意</p>
<pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出
</code></pre><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><pre><code>call 存储过程名(实参列表)
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END
</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>SELECT 函数名（实参列表）
</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>            关键字        调用语法        返回值            应用场景
函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个
存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新
</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p>
<p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;
</code></pre><p>二、会话变量</p>
<p>作用域：针对于当前会话（连接）有效</p>
<pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&#39;read-uncommitted&#39;;
SET SESSION tx_isolation=&#39;read-committed&#39;;
</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p>
<p>声明并初始化：</p>
<pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;
</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre><p>使用：</p>
<pre><code>select @变量名;
</code></pre><p>二、局部变量</p>
<p>声明：</p>
<pre><code>declare 变量名 类型 【default 值】;
</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;
</code></pre><p>使用：</p>
<pre><code>select 变量名
</code></pre><p>二者的区别：</p>
<pre><code>        作用域            定义位置        语法
</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p>
<p>二、case语句</p>
<p>语法：</p>
<pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre><p>特点：<br>    可以用在任何位置</p>
<p>三、if elseif语句</p>
<p>语法：</p>
<pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;
</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;
</code></pre><p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！
</code></pre>]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Til the Cows Come Home</title>
    <url>/2020/02/06/Til-the-Cows-Come-Home/</url>
    <content><![CDATA[<p><strong>原题链接</strong>：<a href="https://vjudge.net/problem/POJ-2387" target="_blank" rel="noopener">传送门</a></p>
<p><strong>思路</strong>：最短路模板题，但要注意输入可能有重复路径，这里取小一点的路径<br>```c++</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn = 1005,inf = 1e9;
int g[maxn][maxn],t,n,a,b,c,vis[maxn],dis[maxn];
int min_dis(){
    int min_val = INT_MAX,min_index;
    for(int i = 1;i &lt;= n;++i){
        if(!vis[i] &amp;&amp; dis[i] &lt; min_val){
            min_val = dis[i],min_index = i; 
        }
    }
    return min_index;
}
int main(){
    fill(g[0],g[0]+maxn*maxn,inf);
    fill(vis,vis+maxn,0);
    fill(dis,dis+maxn,inf);
    scanf(&quot;%d %d&quot;,&amp;t,&amp;n);
    while(t--){
        scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); 
        //坑点，需要加个判断
        if(c&lt;g[a][b])g[a][b] = g[b][a] = c;
    }
    dis[n] = 0;
    for(int i = 1;i &lt; n;++i){
        int u = min_dis();
        vis[u] = 1;
        for(int v = 1;v &lt;= n;++v){
            if(!vis[v] &amp;&amp; g[u][v] != inf &amp;&amp; dis[u] + g[u][v] &lt; dis[v])
                dis[v] = dis[u] + g[u][v];
        }
    }
    printf(&quot;%d&quot;,dis[1]);
    return 0; 
}
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/2020/06/21/Tomcat/</url>
    <content><![CDATA[<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ol>
<li>下载：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></li>
<li>安装：解压压缩包即可。<ul>
<li>注意：安装目录建议不要有中文和空格</li>
</ul>
</li>
<li>卸载：删除目录就行了</li>
<li><p>启动：</p>
<ul>
<li>bin/startup.bat ,双击运行该文件即可</li>
<li><p>访问：浏览器输入：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 回车访问自己</p>
<pre><code>              http://别人的ip:8080 访问别人
</code></pre></li>
<li><p>可能遇到的问题：</p>
<ol>
<li><p>黑窗口一闪而过：</p>
<ul>
<li>原因： 没有正确配置JAVA_HOME环境变量</li>
<li>解决方案：正确配置JAVA_HOME环境变量</li>
</ul>
</li>
<li><p>启动报错：</p>
<ol>
<li>暴力：找到占用的端口号，并且找到对应的进程，杀死该进程<ul>
<li>netstat -ano</li>
</ul>
</li>
<li>温柔：修改自身的端口号<ul>
<li>conf/server.xml</li>
<li><Connector port="8888" protocol="HTTP/1.1"
  connectionTimeout="20000"
  redirectPort="8445" /></li>
<li>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。<ul>
<li>好处：在访问时，就不用输入端口号</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>关闭：<ol>
<li>正常关闭：<ul>
<li>bin/shutdown.bat</li>
<li>ctrl+c</li>
</ul>
</li>
<li>强制关闭：<ul>
<li>点击启动窗口的×</li>
</ul>
</li>
</ol>
</li>
<li><p>配置:</p>
<ul>
<li><p>部署项目的方式：</p>
<ol>
<li><p>直接将项目放到webapps目录下即可。</p>
<ul>
<li>/hello：项目的访问路径—&gt;虚拟目录</li>
<li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下。<ul>
<li>war包会自动解压缩</li>
</ul>
</li>
</ul>
</li>
<li><p>配置conf/server.xml文件<br> 在<Host>标签体中配置<br> <Context docBase="D:\hello" path="/hehe" /></p>
<ul>
<li>docBase:项目存放的路径</li>
<li>path：虚拟目录</li>
</ul>
</li>
<li><p>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写<br> <Context docBase="D:\hello" /></p>
<ul>
<li>虚拟目录：xml文件的名称</li>
</ul>
</li>
</ol>
</li>
<li><p>静态项目和动态项目：</p>
<ul>
<li>目录结构<ul>
<li>java动态项目的目录结构：<br>  — 项目的根目录<pre><code>  -- WEB-INF目录：
      -- web.xml：web项目的核心配置文件
      -- classes目录：放置字节码文件的目录
      -- lib目录：放置依赖的jar包
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>* 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。
</code></pre><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><h3 id="无法访问"><a href="#无法访问" class="headerlink" title="无法访问"></a>无法访问</h3><ul>
<li>安装完firewalld后，会阻挡8080端口，重新开放即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp 添加端口</span><br><span class="line">firewall-cmd --reload 重启防火墙</span><br><span class="line">firewall-cmd --zone&#x3D;public --query-port&#x3D;8080&#x2F;tcp 查询端口状态</span><br></pre></td></tr></table></figure></li>
<li>在servel.xml更改端口为80后无法访问可能是启动时为非root用户启动，所以更好的方法是使用iptables将80端口转发为8080端口即可直接用ip访问</li>
</ul>
<h3 id="配置idea远程部署与访问"><a href="#配置idea远程部署与访问" class="headerlink" title="配置idea远程部署与访问"></a>配置idea远程部署与访问</h3>]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>best cow line</title>
    <url>/2020/02/06/best-cow-line/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=3617" target="_blank" rel="noopener"><strong>描述</strong></a><br>有n头奶牛，重新排序并输出，每80个换一行，使得字典序最小，但只能从头添加到新列或从尾添加到新列，以下是AC代码。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> ch[maxn],ans[maxn];</span><br><span class="line"><span class="comment">//check when ch[a] == ch[b]</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;	<span class="comment">//return 1 then from left,return 0 then from right </span></span><br><span class="line">	<span class="keyword">if</span>(a == b)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ch[a] == ch[b])<span class="keyword">return</span> check(a+<span class="number">1</span>,b<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> ch[a] &lt; ch[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)<span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;ch[i]);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>,r = len - <span class="number">1</span>,id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[l] == ch[r])&#123;</span><br><span class="line">			<span class="keyword">if</span>(check(l,r))&#123;</span><br><span class="line">				ans[id] = ch[l++];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				ans[id] = ch[r--];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[l] &lt; ch[r])&#123;</span><br><span class="line">			ans[id] = ch[l++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans[id] = ch[r--];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//output</span></span><br><span class="line">		<span class="built_in">putchar</span>(ans[id++]);</span><br><span class="line">		<span class="keyword">if</span>(id % <span class="number">80</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>at1999 candy piles</title>
    <url>/2020/05/16/at1999-candy-piles/</url>
    <content><![CDATA[<p><a href="https://atcoder.jp/contests/agc002/tasks/agc002_e" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>介绍：n堆糖果，两个人轮流吃，要么所有的减一，要么直接吃一堆，吃完的人输掉，求第一个人会赢还是第二个人会赢</li>
<li>算法：将糖果的堆转化为网格表，就可以做了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100010</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx=<span class="number">0</span>,dy=a[p]-p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p+<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=p)++dx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dx&amp;<span class="number">1</span>||dy&amp;<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">"First"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Second"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>]&amp;<span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">"Second"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"First"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i+<span class="number">1</span>]&lt;i+<span class="number">1</span>)&#123;</span><br><span class="line">            p=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2020/06/11/XML/</url>
    <content><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ol>
<li>XML<ol>
<li>概念</li>
<li>语法</li>
<li>解析</li>
</ol>
</li>
</ol>
<h2 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h2><ol>
<li><p>概念：Extensible Markup Language 可扩展标记语言</p>
<ul>
<li><p>可扩展：标签都是自定义的。 <user>  <student></p>
</li>
<li><p>功能</p>
<ul>
<li>存储数据<ol>
<li>配置文件</li>
<li>在网络中传输</li>
</ol>
</li>
</ul>
</li>
<li><p>xml与html的区别</p>
<ol>
<li>xml标签都是自定义的，html标签是预定义。</li>
<li>xml的语法严格，html语法松散</li>
<li>xml是存储数据的，html是展示数据</li>
</ol>
</li>
<li><p>w3c:万维网联盟</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li>基本语法：<ol>
<li>xml文档的后缀名 .xml</li>
<li>xml第一行必须定义为文档声明</li>
<li>xml文档中有且仅有一个根标签</li>
<li>属性值必须使用引号(单双都可)引起来</li>
<li>标签必须正确关闭</li>
<li>xml标签名称区分大小写</li>
</ol>
</li>
<li><p>快速入门：<br>  &lt;?xml version=’1.0’ ?&gt;</p>
  <users>
      <user id='1'>
          <name>zhangsan</name>
          <age>23</age>
          <gender>male</gender>
          <br/>
      </user>

      <user id='2'>
          <name>lisi</name>
          <age>24</age>
          <gender>female</gender>
      </user>
  </users>
</li>
<li><p>组成部分：</p>
<ol>
<li>文档声明<ol>
<li>格式：&lt;?xml 属性列表 ?&gt;</li>
<li>属性列表：<ul>
<li>version：版本号，必须的属性</li>
<li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li>
<li>standalone：是否独立<ul>
<li>取值：<ul>
<li>yes：不依赖其他文件</li>
<li>no：依赖其他文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>指令(了解)：结合css的<ul>
<li>&lt;?xml-stylesheet type=”text/css” href=”a.css” ?&gt;</li>
</ul>
</li>
<li><p>标签：标签名称自定义的</p>
<ul>
<li>规则：<ul>
<li>名称可以包含字母、数字以及其他的字符 </li>
<li>名称不能以数字或者标点符号开始 </li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li>
<li>名称不能包含空格 </li>
</ul>
</li>
</ul>
</li>
<li><p>属性：<br> id属性值唯一</p>
</li>
<li>文本：<ul>
<li>CDATA区：在该区域中的数据会被原样展示<ul>
<li>格式：  &lt;![CDATA[ 数据 ]]&gt;</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code>* 约束：规定xml文档的书写规则
    * 作为框架的使用者(程序员)：
        1. 能够在xml中引入约束文档
        2. 能够简单的读懂约束文档

    * 分类：
        1. DTD:一种简单的约束技术
        2. Schema:一种复杂的约束技术


    * DTD：
        * 引入dtd文档到xml文档中
            * 内部dtd：将约束规则定义在xml文档中
            * 外部dtd：将约束的规则定义在外部的dtd文件中
                * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;
                * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;


    * Schema:
        * 引入：
            1.填写xml文档的根元素
            2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;
            4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot; 

        &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xmlns=&quot;http://www.itcast.cn/xml&quot;
            xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;
</code></pre><ol>
<li><p>解析：操作xml文档，将文档中的数据读取到内存中</p>
<ul>
<li><p>操作xml文档</p>
<ol>
<li>解析(读取)：将文档中的数据读取到内存中</li>
<li>写入：将内存中的数据保存到xml文档中。持久化的存储</li>
</ol>
</li>
<li><p>解析xml的方式：</p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul>
<li>优点：操作方便，可以对文档进行CRUD的所有操作</li>
<li>缺点：占内存</li>
</ul>
</li>
<li>SAX：逐行读取，基于事件驱动的。<ul>
<li>优点：不占内存。</li>
<li>缺点：只能读取，不能增删改</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<pre><code>* xml常见的解析器：
    1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
    2. DOM4J：一款非常优秀的解析器
    3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
    4. PULL：Android操作系统内置的解析器，sax方式的。


* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。
    * 快速入门：
        * 步骤：
            1. 导入jar包
            2. 获取Document对象
            3. 获取对应的标签Element对象
            4. 获取数据

    * 代码：
            //2.1获取student.xml的path
        String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
        //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document
        Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);
        //3.获取元素对象 Element
        Elements elements = document.getElementsByTag(&quot;name&quot;);

        System.out.println(elements.size());
        //3.1获取第一个name的Element对象
        Element element = elements.get(0);
        //3.2获取数据
        String name = element.text();
        System.out.println(name);

* 对象的使用：
    1. Jsoup：工具类，可以解析html或xml文档，返回Document
        * parse：解析html或xml文档，返回Document
            * parse​(File in, String charsetName)：解析xml或html文件的。
            * parse​(String html)：解析xml或html字符串
            * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
    2. Document：文档对象。代表内存中的dom树
        * 获取Element对象
            * getElementById​(String id)：根据id属性值获取唯一的element对象
            * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
            * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
            * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合
    3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用
    4. Element：元素对象
        1. 获取子元素对象
            * getElementById​(String id)：根据id属性值获取唯一的element对象
            * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合
            * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合
            * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合

        2. 获取属性值
            * String attr(String key)：根据属性名称获取属性值
        3. 获取文本内容
            * String text():获取文本内容
            * String html():获取标签体的所有内容(包括字标签的字符串内容)
    5. Node：节点对象
        * 是Document和Element的父类


* 快捷查询方式：
    1. selector:选择器
        * 使用的方法：Elements    select​(String cssQuery)
            * 语法：参考Selector类中定义的语法
    2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言
        * 使用Jsoup的Xpath需要额外导入jar包。
        * 查询w3cshool参考手册，使用xpath的语法完成查询
        * 代码：
            //1.获取student.xml的path
            String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();
            //2.获取Document对象
            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);

            //3.根据document对象，创建JXDocument对象
            JXDocument jxDocument = new JXDocument(document);

            //4.结合xpath语法查询
            //4.1查询所有student标签
            List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);
            for (JXNode jxNode : jxNodes) {
                System.out.println(jxNode);
            }

            System.out.println(&quot;--------------------&quot;);

            //4.2查询所有student标签下的name标签
            List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);
            for (JXNode jxNode : jxNodes2) {
                System.out.println(jxNode);
            }

            System.out.println(&quot;--------------------&quot;);

            //4.3查询student标签下带有id属性的name标签
            List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);
            for (JXNode jxNode : jxNodes3) {
                System.out.println(jxNode);
            }
            System.out.println(&quot;--------------------&quot;);
            //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast

            List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#39;itcast&#39;]&quot;);
            for (JXNode jxNode : jxNodes4) {
                System.out.println(jxNode);
            }
</code></pre>]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>c++快读整数</title>
    <url>/2020/02/09/c-%E5%BF%AB%E8%AF%BB%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>一般来讲，c++读入一个整数可以使用cin或者scanf()，而且scanf()函数会快一点，然而在大批整数的读取过程中，可以使用getchar()函数读取，速度更快，更省时间，因为scanf()需要缓冲，需要解析字符串，而getchar()直接读入一个字符，同理，putchar()也比printf()快一点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">	<span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) res = res\*<span class="number">10</span> + c - <span class="number">48</span>,c = getchar();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>git 基础</title>
    <url>/2020/05/28/git-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>这篇文章将告诉你如何配置git，以及学完这篇文章后，你将可以将本地的代码提交到GitHub，并且从GitHub下载代码，以及更新，回溯代码。</p>
<h2 id="获得一个git仓库"><a href="#获得一个git仓库" class="headerlink" title="获得一个git仓库"></a>获得一个git仓库</h2><p>有两种方法</p>
<ul>
<li>本地初始化一个仓库<ul>
<li>cd project</li>
<li>git init</li>
</ul>
</li>
<li>从GitHub clone一个仓库<ul>
<li>git clone url<br>无论哪一种，最后都可以获得一个仓库</li>
</ul>
</li>
</ul>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><ul>
<li>git add *.py</li>
<li>git commit -a 本地提交所有修改</li>
<li>git push &lt; name &gt;<ul>
<li>之前要设置git remote add &lt; name &gt; &lt; url &gt;</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2020/08/01/Trie%E6%A0%91/</url>
    <content><![CDATA[<ul>
<li>常用操作：插入，查询</li>
<li>通常不是作为一个单独的考察点，而是伴随着其他算法一起使用，如ac自动机等等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ext[i]表示第i棵树是否为字母节点,trie[i][j]为第i棵树的第j的位置存放的下一棵树的坐标,cnt为树的坐标，每一棵树都有坐标</span></span><br><span class="line"><span class="comment">//每一棵树都代表着一个字母</span></span><br><span class="line"><span class="keyword">int</span> ext[MAXN],trie[MAXN][<span class="number">26</span>],cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trie_insert</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),root = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> id = str[i]-<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(trie[root][id]==<span class="number">0</span>)</span><br><span class="line">			trie[root][id]=++cnt;</span><br><span class="line">		root = trie[root][id];</span><br><span class="line">	&#125;</span><br><span class="line">	ext[cnt]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trie_query</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str),root = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> id = str[i] - <span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(!trie[root][id])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		root = trie[root][id];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ext[root];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>bfs模板</title>
    <url>/2020/03/08/bfs%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>传送门：<a href="https://vjudge.net/contest/65959#problem/B" target="_blank" rel="noopener">链接</a></p>
<p>【题目描述】 这题是一个三维的迷宫题目，其中用‘.’表示空地，‘#’表示障碍物，‘S’表示起点，‘E’表示终点，求从起点到终点的最小移动次数，解法和二维的类似，只是在行动时除了东南西北移动外还多了上下。可以上下左右前后移动，每次都只能移到相邻的空位，每次需要花费一分钟，求从起点到终点最少要多久。</p>
<p>题解：使用队列stl配合bfs，其中要注意一些细节问题，例如getchar()函数的使用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> z, x, y, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> l, r, c, sx, sy, sz, ez, ex, ey;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">char</span> g[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="built_in">point</span>&gt;q;</span><br><span class="line">	q.push(&#123;sz,sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">	vis[sz][sx][sy] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="built_in">point</span> t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (g[t.z][t.x][t.y] == <span class="string">'E'</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Escaped in "</span> &lt;&lt; t.cnt &lt;&lt; <span class="string">" minute(s)."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> tz = t.z + dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> tx = t.x + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> ty = t.y + dir[i][<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">if</span> (tz &gt;= <span class="number">0</span> &amp;&amp; tz &lt; l &amp;&amp; tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; r &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; c &amp;&amp; !vis[tz][tx][ty] &amp;&amp; g[tz][tx][ty] != <span class="string">'#'</span>) &#123;</span><br><span class="line">				vis[tz][tx][ty] = <span class="number">1</span>;</span><br><span class="line">				q.push(&#123; tz, tx, ty, t.cnt + <span class="number">1</span> &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Trapped!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"sample.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>); </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c) &amp;&amp; l) &#123;</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; ++j) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; c; ++k) &#123;</span><br><span class="line">					g[i][j][k] = getchar();</span><br><span class="line">					<span class="keyword">if</span> (g[i][j][k] == <span class="string">'S'</span>)sz = i, sx = j, sy = k;</span><br><span class="line">					<span class="keyword">if</span> (g[i][j][k] == <span class="string">'E'</span>)ez = i, ex = j, ey = k;</span><br><span class="line">				&#125;</span><br><span class="line">				getchar();</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>java in ubuntu相关环境配置</title>
    <url>/2020/06/06/java-in-ubuntu%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="JAVA-running-envirment"><a href="#JAVA-running-envirment" class="headerlink" title="JAVA running envirment"></a>JAVA running envirment</h2><p>sudo apt update<br>sudo apt install openjdk-8-jdk </p>
<h2 id="Apeche配置"><a href="#Apeche配置" class="headerlink" title="Apeche配置"></a>Apeche配置</h2><p>安装java8后，可以配置apeche了<br>介绍：Apache is the most widely used web server software. Developed and maintained by Apache Software Foundation, Apache is an open source software available for free. It runs on 67% of all webservers in the world. It is fast, reliable, and secure.</p>
<p>sudo apt install apeche2</p>
<h3 id="添加子网方法"><a href="#添加子网方法" class="headerlink" title="添加子网方法"></a>添加子网方法</h3><p>前提：购买了域名并且解析为这个服务器的公网ip</p>
<ol>
<li>cd/var/www/,mkdir gci,sudo vim index.html</li>
<li>cd /etc/apache2/sites-available/</li>
<li>sudo cp 000-default.conf gci.conf</li>
<li>sudo vim gci.conf</li>
<li>修改至自己的域名ServerAdmin yourname@example.com,DocumentRoot /var/www/gci/,ServerName gci.example.com</li>
<li>激活sudo a2ensite gci.conf， systemctl reload apache2</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python 画图</title>
    <url>/2020/06/01/python-%E7%94%BB%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//简单的折线图</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">60</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">120</span>,<span class="number">140</span>,<span class="number">180</span>,<span class="number">200</span>]</span><br><span class="line">y = [<span class="number">2.068</span>,<span class="number">0.818</span>,<span class="number">0.337</span>,<span class="number">0.298</span>,<span class="number">0.160</span>,<span class="number">0.112</span>,<span class="number">0.112</span>,<span class="number">0.096</span>,<span class="number">0.096</span>,<span class="number">0.096</span>,<span class="number">0.096</span>,<span class="number">0.096</span>]</span><br><span class="line"></span><br><span class="line">//画图函数</span><br><span class="line">plt.plot(x, y, color=<span class="string">"r"</span>, linestyle=<span class="string">"-"</span>, marker=<span class="string">"."</span>, linewidth=<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">//标题</span><br><span class="line">plt.title(<span class="string">"Curve of current density with time"</span>)</span><br><span class="line"></span><br><span class="line">//坐标轴标签</span><br><span class="line">plt.xlabel(<span class="string">"T/s"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"I/(mA/cm^2)"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>manacher算法</title>
    <url>/2020/05/13/manacher%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>介绍：manacher俗称马拉车算法，可以在O(n)时间内解决求n长度的字符串每个位置的最长回文串长度</li>
<li>思路：<ul>
<li>先预处理插入特殊字符，使得所有奇偶串都成为奇串</li>
<li>再根据回文串对称的特性，假设i再mid位的回文串里面，根据对称特性可以减少运算</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(A,B)(A&lt;B?A:B)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32000005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N],st[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,st);</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">'~'</span>;</span><br><span class="line">    reg <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">1</span>,len = <span class="built_in">strlen</span>(st);</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; len;++i)&#123;</span><br><span class="line">        s[j++]=<span class="string">'#'</span>;</span><br><span class="line">        s[j++]=st[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s[j++]=<span class="string">'#'</span>;</span><br><span class="line">    s[j]=<span class="string">'$'</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    reg <span class="keyword">int</span> len = init(),r = <span class="number">1</span>,mid = <span class="number">1</span>,ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; r)p[i] = MIN(p[mid*<span class="number">2</span>-i],r-i+<span class="number">1</span>);  <span class="comment">//如果小于已知最长回文串的右端点</span></span><br><span class="line">        <span class="keyword">else</span> p[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i+p[i]]==s[i-p[i]])++p[i];  <span class="comment">//笨便利，由这个知道是O(n)复杂度</span></span><br><span class="line">        <span class="keyword">if</span>(r &lt; p[i]+i<span class="number">-1</span>)&#123;               <span class="comment">//更新右端点</span></span><br><span class="line">            r = p[i]+i<span class="number">-1</span>;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; p[i])ans = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown常用语法</title>
    <url>/2020/01/19/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="以下…表示内容"><a href="#以下…表示内容" class="headerlink" title="以下…表示内容"></a>以下…表示内容</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote>
<p>#     一级标题<br>##    二级标题<br>###    三级标题</p>
</blockquote>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><blockquote>
<p>使用一个及以上的空行表示分割开的段落</p>
</blockquote>
<h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><blockquote>
<p>**…**<br>__…__</p>
</blockquote>
<h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><blockquote>
<p>*…*        _…_</p>
</blockquote>
<h2 id="加粗且斜体"><a href="#加粗且斜体" class="headerlink" title="加粗且斜体"></a>加粗且斜体</h2><blockquote>
<p>***…**<em><br>___…___<br>\</em>*_…_**</p>
</blockquote>
<h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><ul>
<li><p>一般块引用</p>
<blockquote>
<p>>…</p>
</blockquote>
</li>
<li><p>多段块引用    </p>
<blockquote>
<p>>…<br>><br>>…</p>
</blockquote>
</li>
<li>嵌套块引用    <blockquote>
<p>>…<br>><br>>&gt;…</p>
</blockquote>
</li>
</ul>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>内容前面添加*(+-)</p>
<h2 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h2><blockquote>
<p>`…`    表示一个单词为代码<br>``…``    可以让…中含有`<br>一大段代码直接上下空一行表示独立一段并且所有代码前进一个tab位</p>
</blockquote>
<h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><blockquote>
<p>***<br>---<br><strong><strong>_</strong></strong>___</p>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote>
<p>带名字网址引用<strong>[名字](网址)</strong><br>不带名字的网址引用<strong>\<urls></strong><br>图片            <strong>![标题](地址)</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫入门</title>
    <url>/2020/05/29/python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>简单的爬虫的话，就是对一个网站发送http请求，获取http页面，再用正则表达式匹配获取需要的字符串，再对字符串进行所需要的处理，例如文本，音频，视频的下载</p>
<p>但是后面复杂的爬虫，就是在这个无数的页面当中，筛选出自己需要的高质量的数据，这就有一个搜索策略的问题，对爬取的大量数据进行处理也是一个大数据领域和人工智能的问题。</p>
<p>下面提一下简单爬虫的做法</p>
<h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>get函数：直接获取html页面，返回一个Response对象<br>r.text：解析页面为text类型<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(URL)</span><br><span class="line">r.text</span><br></pre></td></tr></table></figure></p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>ac自动机</title>
    <url>/2020/08/01/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3796" target="_blank" rel="noopener">模版题链接</a></p>
<ul>
<li><a href="https://blog.csdn.net/bestsort/article/details/82947639" target="_blank" rel="noopener">最易懂的参考资料</a></li>
<li>学习ac自动机需要前置知识：Trie树(也叫前缀树或字典树)和KMP</li>
<li>思路：<ol>
<li>建trie树</li>
<li>在树上建fail指针</li>
<li>可以开始愉快的查询了</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> wds[N];</span><br><span class="line"><span class="keyword">int</span> fail[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">char</span> wd[N][<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建字典树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_trie</span><span class="params">(<span class="keyword">char</span>* ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span>,len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">	FOR(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">		<span class="keyword">int</span> id = ch[i]-<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(!trie[rt][id])trie[rt][id]=++cnt;</span><br><span class="line">		rt=trie[rt][id];</span><br><span class="line">	&#125;</span><br><span class="line">	wds[rt]++;</span><br><span class="line">    <span class="built_in">strcpy</span>(wd,ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建fail点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">0</span>,<span class="number">26</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[<span class="number">0</span>][i])&#123;</span><br><span class="line">			q.push(trie[<span class="number">0</span>][i]);</span><br><span class="line">			fail[trie[<span class="number">0</span>][i]]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		rt = q.front();q.pop();</span><br><span class="line">		FOR(i,<span class="number">0</span>,<span class="number">26</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(trie[rt][i])&#123;</span><br><span class="line">				q.push(trie[rt][i]);</span><br><span class="line">				fail[trie[rt][i]] = trie[fail[rt]][i];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				trie[rt][i]=trie[fail[rt]][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询，此处可根据题目进行相应的修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>* ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>,rt = <span class="number">0</span>,len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">	FOR(i,<span class="number">0</span>,len)&#123;</span><br><span class="line">		rt = trie[rt][ch[i]-<span class="string">'a'</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = rt;j &amp;&amp; wds[j]!=<span class="number">-1</span>;j=fail[j])&#123;</span><br><span class="line">			res += wds[j];</span><br><span class="line">			wds[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>主席树</title>
    <url>/2020/05/16/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>主席树是利用函数式的编程思想使得线段树支持查询历史版本，同时充分利用他们之间的共同数据来减少时间和内存消耗的数据结构。也就是说，主席树是多颗线段树的集合.</li>
<li>可加减性：比如i,j两棵树，求i-j区间中的第k大的值，<h2 id="静态主席树"><a href="#静态主席树" class="headerlink" title="静态主席树"></a>静态主席树</h2>树建好之后不会改变树上的值<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+r)/2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,q,cnt;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],T[N];</span><br><span class="line"><span class="keyword">int</span> sum[N&lt;&lt;<span class="number">5</span>],L[N&lt;&lt;<span class="number">5</span>],R[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123; <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        L[rt]=build(l,mid);</span><br><span class="line">        R[rt]=build(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[v]]-sum[L[u]];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k)<span class="keyword">return</span> query(L[u],L[v],l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(R[u],R[v],mid+<span class="number">1</span>,r,k-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;  <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">int</span> rt = ++cnt;</span><br><span class="line">    L[rt]=L[pre],R[rt]=R[pre],sum[rt]=sum[pre]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid)L[rt]=update(L[pre],l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> R[rt]=update(R[pre],mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;q);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">    m = unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">    T[<span class="number">0</span>]=build(<span class="number">1</span>,m);</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+m,a[i])-b;  <span class="comment">//得到a[i]在b数组的坐标</span></span><br><span class="line">        T[i]=update(T[i<span class="number">-1</span>],<span class="number">1</span>,m,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[query(T[x<span class="number">-1</span>],T[y],<span class="number">1</span>,m,z)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态主席树"><a href="#动态主席树" class="headerlink" title="动态主席树"></a>动态主席树</h2>树建好后树上的值还会发生改变，比如区间上加值，这就跟线段树差不多了，只是更新那一条链上的值，其他的链直接跟上一颗一样即可</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2020/07/09/matlab/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>origin</title>
    <url>/2020/07/09/origin/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>二分法</title>
    <url>/2020/08/19/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>一般来讲，二分法用在一个有序序列中求某个值的位置</p>
<p>可是可以展开来看，将某个值广泛为一个答案，那么每次求解时都是相当于在一个单调函数f(mid)中求解最终的答案，也就是必须构造出一个函数f，使其答案y为f的一个函数，而且这个函数关于x是单调的，于是我们在知道最优的一个解y时，能够得到对应最接近的一个x</p>
<p>根据以上，二分法于是就可以解决一些最大化最小值，最大化平均值，查找第k大的值，最大化第k打的值等等。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>spss</title>
    <url>/2020/07/09/spss/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/2020/02/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><p>矩阵型</p>
</li>
<li><p>序列型</p>
</li>
<li><p>双序列型</p>
</li>
<li><p>划分型</p>
</li>
<li><p>区间型</p>
</li>
<li><p>背包型</p>
</li>
<li><p>状态压缩型</p>
</li>
<li><p>树型</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础</title>
    <url>/2020/06/06/web/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>JavaWeb:使用Java语言开发基于互联网的网页</li>
<li>软件架构<ul>
<li>C/S结构:客户端/服务器架构</li>
<li>B/S架构:浏览器/服务器架构</li>
</ul>
</li>
<li>资源<ul>
<li>静态资源:文字，图片，视频等资源，HTML，CSS，JS语言去实现</li>
<li>动态资源:动态网页发布的资源，如jsp/servlet，服务器会把动态资源转为静态资源再发到浏览器。</li>
</ul>
</li>
</ul>
<h2 id="Html"><a href="#Html" class="headerlink" title="Html"></a>Html</h2><ul>
<li>概念:Hyper Text Markup Language超文本标记语言</li>
<li>Notes:标记语言不是编程语言，没有逻辑性，只需要把这个标签打上去就行。</li>
<li>语法<ol>
<li>html文件后缀:html，htm</li>
<li>标签分为<ul>
<li>围堵标签，由开始标签和闭合标签组成，如&lt; head &gt;&lt; /head &gt;，可以嵌套</li>
<li>自闭合标签，开始标签和闭合标签为一体，如&lt; br/ &gt;</li>
</ul>
</li>
<li>开始标签中可以定义属性，属性由键值对构成，需要用引号引起来(单引双引都可以)</li>
</ol>
</li>
<li>标签<ul>
<li>文件标签:构成html最基本的内容<ul>
<li>html:根标签</li>
<li>head:头标签。指定html文档的属性，引入外部的资源</li>
<li>title:标题标签</li>
<li>body:体标签</li>
<li>&lt; !DOCTYPE html&gt;:h5定义该文档为html文档</li>
</ul>
</li>
<li>文本标签:<ul>
<li>&lt; !— — &gt;:注释标签</li>
<li>h1-h6:标题标签</li>
<li>p:段落标签</li>
<li>br:换行标签</li>
<li>hr:显示水平线 </li>
<li>b:字体加粗</li>
<li>i:字体斜体 </li>
</ul>
</li>
<li>图片标签:<ul>
<li>img<ul>
<li>src:图片路径</li>
<li>绝对路径(//)</li>
<li>相对路径(./src)，以点开头</li>
</ul>
</li>
</ul>
</li>
<li>列表标签<ul>
<li>li:列表项，封装在列表其中</li>
<li>ol:有序列表</li>
<li>ul:无序列表 </li>
</ul>
</li>
<li>链接标签<ul>
<li>a:标签<ul>
<li>href:资源网址，可以是url，也可以是本地的资源，打开客户端等</li>
<li>target:url是否在本页面打开</li>
</ul>
</li>
</ul>
</li>
<li>快标签<ul>
<li>把代码包裹出来，便于css进行样式选择</li>
<li>span:行内标签</li>
<li>div:块级标签</li>
</ul>
</li>
<li>语义化标签<ul>
<li>概念:提高程序可读性</li>
<li>header:页眉</li>
<li>footer:页脚</li>
</ul>
</li>
<li>表格标签<ul>
<li>table标签包裹</li>
<li>tr:行标签</li>
<li>td:单元格标签</li>
<li>th:表头单元格</li>
<li>caption:表格标题</li>
<li>thead:表格头</li>
<li>tbody:表格体</li>
<li>tfoot:表格脚</li>
</ul>
</li>
<li>表单标签<ul>
<li>概念:用于采集用户输入的数据，用于和服务器交互</li>
<li>form标签:定义一个输入的范围，提高可读性<ul>
<li>input:输入标签<ul>
<li>type属性:<ul>
<li>text:文本输入框</li>
<li>password:密码输入框</li>
<li>radio:单选框<ul>
<li>注意:要使多个单选框实现单选的效果，那么必须使得name属性值相同</li>
<li>如果要使得能提交到服务器，那么必须指定value的值</li>
</ul>
</li>
<li>checkbox:复选框<ul>
<li>同单选框的注意事项，但是可以实现多选</li>
</ul>
</li>
<li>file:文件提交框，用于提交文件</li>
<li>hidden:隐藏域，用于提交用户看不到的信息</li>
<li>checkcode:验证码</li>
<li>submit:提交框<ul>
<li>提交表单数据到服务器</li>
</ul>
</li>
<li>image:图片提交按钮，点击会提交表单</li>
</ul>
</li>
<li>placeholder:指定输入框的提示文字</li>
<li>lable:指定输入项的文字提示，for属性可以和后面的input标签的id属性对应，进而点击会进入input框 </li>
</ul>
</li>
<li>select:下拉列表<ul>
<li>option:指定下拉列表的值</li>
<li>提交成功的前提是select的name不为空，option的value不为空</li>
</ul>
</li>
<li>textvalue:文本域<ul>
<li>rows，cols:限制多少行和列</li>
</ul>
</li>
</ul>
</li>
<li>属性:action，method</li>
<li>GET与POST请求的区别:GET会直接将请求封装到请求行中，POST会将请求加入到请求体中，GET对请求长度有要求，POST无要求，GET不安全，POST较安全</li>
</ul>
</li>
</ul>
</li>
<li>静态html开发流程<ul>
<li>观察布局，使用table</li>
<li>如果某一行一个单元格，就一个tr+td</li>
<li>如果多个单元格，那么嵌套一个表格tr+table+td</li>
</ul>
</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol>
<li>概念:Cascading Style Sheets，用于页面的美化和布局工作</li>
<li>好处:降低耦合度，让分工协作更容易，提高开发效率</li>
<li>使用方式<ol>
<li>内联方式<ul>
<li>在当前的标签生效，不常用</li>
</ul>
</li>
<li>内部样式<ul>
<li>相当于这个文件的全局样式</li>
<li>格式为<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>外部样式<ul>
<li>在外部定义.css文件</li>
<li>需要的时候用link直接引入</li>
</ul>
</li>
</ol>
</li>
<li>css语法<ul>
<li>格式:<br>选择器{<br>  属性名:属性值；<br>  属性名:属性值；<br>}  </li>
<li>筛选具有相似特征的元素，每一个属性需要用分号隔开</li>
</ul>
</li>
<li>选择器:定义在style标签内的选择器，而摈弃了全局的样式选择<ul>
<li>基本选择器<ul>
<li>id选择器:选择具体id属性的元素<ul>
<li>语法:#id属性值{}</li>
<li>注意一般只用一次</li>
</ul>
</li>
<li>元素选择器:选择元素名代表的样式<ul>
<li>语法:元素名称{}</li>
</ul>
</li>
<li>类选择器<ul>
<li>.类名{}</li>
</ul>
</li>
</ul>
</li>
<li>扩展选择器<ul>
<li>选择所有元素 *{}</li>
<li>并集选择器:x1和x2标签 x1，x2{}</li>
<li>子选择器:x1下的x2标签 x1 x2{}  </li>
<li>父选择器:x2上的x1标签 x1 &gt; x2{}</li>
<li>属性选择器:标签名称[属性名=属性值]{}，通常用于输入框的状态</li>
<li>伪类选择器:选择一些标签具有的状态，通常用于链接的状态</li>
</ul>
</li>
<li>选择器直接在其他标签内使用即可，例如类就是标签内指定class=类名</li>
</ul>
</li>
<li>属性 <ul>
<li>字体、文本<ul>
<li>font-size</li>
<li>color</li>
<li>text-align</li>
<li>line-height</li>
</ul>
</li>
<li>背景<ul>
<li>background</li>
</ul>
</li>
<li>边框<ul>
<li>border</li>
</ul>
</li>
<li>尺寸 <ul>
<li>width</li>
<li>height</li>
</ul>
</li>
</ul>
</li>
<li>盒子模型:控制布局，把元素的集合看做一个盒子<ul>
<li>margin:外边距</li>
<li>padding:内边距<ul>
<li>默认内边距会影响盒子大小，可使用box-sizing=border-box指定大小 </li>
</ul>
</li>
<li>float:left，right</li>
</ul>
</li>
</ol>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul>
<li>基本概念:客户端脚本语言，每个浏览器都有JS的解析引擎</li>
<li>功能:增强用户与html页面的交互</li>
<li>JavaScript = ECMAScript + JavaScript特有的东西</li>
</ul>
<h3 id="ECMAscript"><a href="#ECMAscript" class="headerlink" title="ECMAscript"></a>ECMAscript</h3><ul>
<li><p>基本语法</p>
<ul>
<li><p>与html结合方式</p>
<ul>
<li>内部js:任意位置都可以，但是执行顺序会不一样，就是先加载或者先执行js代码</li>
<li>外部js:通过script标签和src引入</li>
</ul>
</li>
<li><p>注释:和java一样 //或者/**/</p>
</li>
<li><p>数据类型</p>
<ul>
<li>原始数据类型:<ul>
<li>number:数字。整数、小数、NaN</li>
<li>string:字符串。单引或双引，没有字符的概念</li>
<li>boolean:true和false</li>
<li>null:一个对象为空的占位符</li>
<li>undefined:未定义。一个变量魏碑初始化类型</li>
</ul>
</li>
<li>引用数据类型:即为对象</li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li>js是弱类型语言，不定义变量空间的固定类型</li>
<li>var 变量名 = 值</li>
<li>typeof() 查看数据类型</li>
</ul>
</li>
<li><p>运算符  </p>
<ul>
<li>基本使用方法与java一样</li>
<li>一元运算符:++，—，+（）</li>
<li>二元运算符:+，-，*，\。。。。</li>
<li>赋值运算符:=，+=，-=</li>
<li>比较运算符:&gt;，&lt;，&gt;=，&lt;=，==，===（全等于），，</li>
<li>逻辑运算符:&amp;&amp;，||，!<ul>
<li>对于num类型，0或NaN为false，1为true</li>
<li>string类型，空为false</li>
<li>所有对象都为true</li>
<li>null和undefined为false</li>
</ul>
</li>
<li>三元运算符:，?，:</li>
</ul>
</li>
<li><p>特殊语法</p>
<ul>
<li>js中可以不写分号，如果只有一行的话</li>
</ul>
</li>
<li><p>变量可以用var命名，但是也可以不写var，用var的时候为局部变量，不用的时候为全局变量</p>
</li>
<li><p>流程控制:基本和java一样，除了switch</p>
<ul>
<li>if..else..</li>
<li>while for</li>
<li>switch:可以接受任意的类型，case也可以是任意的类型，同样要加break。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>基本对象</p>
<ul>
<li><p>函数</p>
<ul>
<li>创建<ul>
<li>var fun = new Function(形参列表，方法体);<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>，<span class="string">"b"</span>，<span class="string">"alert(a);"</span>);</span><br><span class="line">fun(<span class="number">3</span>，<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li>function 方法名称(形参列表){方法体}<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a，b</span>)</span>&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;;</span><br><span class="line">fun(<span class="number">3</span>，<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li>var 方法名=function(形参列表){方法体}<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">a，b</span>)</span>&#123;</span><br><span class="line">  alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">3</span>+<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>方法</li>
<li><p>属性</p>
<ul>
<li>length:返回方法的形参个数</li>
</ul>
</li>
<li>特点<ul>
<li>传入参数与形参不一致的时候，后面的参数默认为undefined</li>
<li>方法如果重复定义，会覆盖原来的方法</li>
<li>方法的调用只与方法名称有关，与参数列表无关</li>
<li>在方法声明中有一个内置的对象数组，arguments，封装所有的实参</li>
</ul>
</li>
<li><p>调用 </p>
<ul>
<li>方法名(实参列表)</li>
</ul>
</li>
</ul>
</li>
<li><p>Array:数组对象</p>
<ul>
<li>创建:<ul>
<li>var a = new Array(元素列表);</li>
<li>var a = new Array(默认长度);</li>
<li>var a = [ 元素列表 ];</li>
</ul>
</li>
<li>特点<ul>
<li>数组元素类型可以任意</li>
<li>长度可变</li>
</ul>
</li>
<li>方法<ul>
<li>join:将数组中的元素按指定的分隔符拼接形成字符串</li>
<li>push:向数组的尾部添加元素</li>
</ul>
</li>
</ul>
</li>
<li><p>RegExp:正则表达式对象</p>
<ul>
<li>正则表达式<ul>
<li>单词字符:[]，如[a]，[ab]，[a-zA-Z0-9]，\d(单个数字符号)，\w(单个以上字符)</li>
<li>量词符号<ul>
<li>?:出现0次或1次</li>
<li>*:出现0次或多次</li>
<li>+:出现1次或多次</li>
<li>{m，n}:表示m&lt;=数量&lt;=n，m如果缺省，表示最多n次，n缺省同理</li>
</ul>
</li>
<li>开始与结束<ul>
<li>^:开始</li>
<li>$:结束</li>
</ul>
</li>
</ul>
</li>
<li>正则对象<ul>
<li>创建<ul>
<li>var r = new RegExp(“正则表达式”);注意字符串中的转义</li>
<li>var r = /正则表达式/;推荐这种，因为不用考虑转义</li>
</ul>
</li>
<li>方法<ul>
<li>test(参数):查看是否满足正则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Grobal:全局对象，任意地方都可以调用，不用初始化，方法()<ul>
<li>方法<ul>
<li>encodeURL():url编码，将utf-8转为由16进制数字组成的位字符串</li>
<li>decodeURL():url解码，将位串转为utf-8</li>
<li>encodeURLComponent():同上，但是会编更多的码</li>
<li>decodeURLComponent()</li>
<li>parseInt():将字符串中的字符转为十进制数字，如果非数字，则停止</li>
<li>isNaN():判断某值是否是NaN</li>
<li>eval():讲字符串转为js代码来执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>BOM<ul>
<li>概念:Browser Object Model 浏览器对象模型</li>
<li>组成<ul>
<li>Window对象<ul>
<li>方法<ul>
<li>与弹出窗口有关<ul>
<li>alert():显示一段消息</li>
<li>confirm():如果点击确定返回true，反之，返回false</li>
<li>prompt():显示可提示用户输入的框</li>
</ul>
</li>
<li>与打开关闭有关<ul>
<li>open()，可传入打开窗口的地址</li>
<li>close()，关闭窗口，谁调用关闭谁</li>
</ul>
</li>
<li>与定时器有关的方法<ul>
<li>setTimeout(js代码或方法，时间):一次性定时器</li>
<li>clearTimeout():取消定时器</li>
<li>setInterval():循环定时器</li>
<li>clearInterval:取消循环定时器 </li>
</ul>
</li>
</ul>
</li>
<li>特点:不需要创建，直接使用，引用可以省略</li>
</ul>
</li>
<li>Screen对象</li>
<li>Location对象：是windows的子对象<ul>
<li>方法<ul>
<li>reload()，刷新页面</li>
</ul>
</li>
<li>属性<ul>
<li>href：地址</li>
</ul>
</li>
</ul>
</li>
<li>History对象：表示当前window的历史记录<ul>
<li>创建<ul>
<li>window.history</li>
<li>history</li>
</ul>
</li>
<li>方法<ul>
<li>back()</li>
<li>forward()</li>
<li>go()</li>
</ul>
</li>
<li>属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>DOM:<ul>
<li>概念:Document Object Model</li>
<li>DOM树:通过html的标签形成的树</li>
<li>DOM标准<ul>
<li>核心 DOM:针对任何结构性文档的标准模型<ul>
<li>Document:文档对象</li>
<li>Element:元素对象</li>
<li>Attribute:属性对象</li>
<li>Text:文本对象</li>
<li>Comment:注释对象</li>
</ul>
</li>
<li>XML DOM:针对XML文档的标准模型</li>
<li>HTML DOM:针对HTML文档的标准模型</li>
</ul>
</li>
<li>核心DOM<ul>
<li>Document:文档对象<ul>
<li>创建:window.document</li>
<li>方法<ul>
<li>获取对象<ul>
<li>getElementById():通过id获取元素</li>
<li>getElementsByTagName():通过标签名返回一个数组</li>
<li>getElementsByClassName():根据class的属性值返回对象</li>
<li>getElementsByName():根据name属性值返回对象数组</li>
</ul>
</li>
<li>创建其他DOM对象<ul>
<li>createAttribute()</li>
<li>createComment()</li>
<li>createTextNode()</li>
<li>createElement()</li>
</ul>
</li>
</ul>
</li>
<li>属性 </li>
</ul>
</li>
<li>Element:元素对象<ul>
<li>获取与创建:通过Document获取与创建</li>
<li>方法<ul>
<li>setAttrbute():设置属性</li>
<li>removeAttribute():移除属性</li>
</ul>
</li>
</ul>
</li>
<li>Node:节点对象，公共方法<ul>
<li>特点：所有DOM对象都可以认为是一个节点</li>
<li>方法<ul>
<li>CRUD dom树<ul>
<li>appendChild():添加子节点</li>
<li>removeChild():删除子节点</li>
<li>replaceChind():替换子节点</li>
</ul>
</li>
</ul>
</li>
<li>属性<ul>
<li>parentNode:返回当前节点的父节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>HTML DOM<ul>
<li>标签体的获取和设置:innerHtml<ul>
<li>是一个标签的属性，表示方括号中的内容</li>
<li>替换=，直接通过id获取标签再通过字符串进行更改，可以更改为文本，标签等等</li>
<li>添加+=，如上</li>
</ul>
</li>
<li>使用html元素对象的属性</li>
<li>控制标签样式<ul>
<li>标签的style的子元素进行控制</li>
<li>或者设置标签的类名，直接修改整体的样式，可读性也好点<pre><code class="lang-js">var div1 = document.getElementById(&quot;div1&quot;);
div1.onclick=function(){
div1.style.border=&quot;1px solid red&quot;;
div1.style.width=&quot;200px&quot;;
div1.style.fontSize=&quot;10px&quot;;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>事件<ul>
<li>功能:某些组件被执行了某些操作后，触发某些代码的执行<ul>
<li>事件：如单机，双击，键盘按下，鼠标移动</li>
<li>事件源：组件 </li>
<li>监听器：代码</li>
<li>注册监听：将事件，事件源，监听器结合在一起，当事件源上发生了某个事件，便触发执行某个监听器代码</li>
</ul>
</li>
<li>如何绑定事件<ul>
<li>直接在属性上进行绑定事件，耦合度很高，不利于维护</li>
<li>通过js获取元素再进行修改，可读性高，推荐使用</li>
</ul>
</li>
<li>常见的事件<ul>
<li>点击事件<ul>
<li>onclick：单击事件</li>
<li>ondblclick：双击事件</li>
</ul>
</li>
<li>焦点事件<ul>
<li>onblur：失去焦点</li>
<li>onfocus：获得焦点，例如输入框被点中，进入输入状态</li>
</ul>
</li>
<li>加载事件<ul>
<li>onload：一章页面或一幅图片完成加载</li>
</ul>
</li>
<li>鼠标事件<ul>
<li>onmousedown：鼠标被按下<ul>
<li>定义方法时，定义一个形参，接受event对象</li>
<li>event对象可以定义哪个按键被点击了</li>
</ul>
</li>
<li>onmouseup：鼠标按键被松开</li>
<li>onmonsemove：鼠标被移动</li>
<li>onmouseover：鼠标被移动到某元素之上</li>
<li>onmouseout：鼠标从某元素移开</li>
</ul>
</li>
<li>键盘事件<ul>
<li>onkeydown：键盘被按下</li>
<li>onkeyup：键盘被松开</li>
<li>onkeypress：键盘按键被按下并松开</li>
</ul>
</li>
<li>选择和改变<ul>
<li>onchange：域的内容被改变</li>
<li>onselect：文本被选中</li>
</ul>
</li>
<li>表单事件<ul>
<li>onsubmit：按钮被点击<ul>
<li>可以检查表单，阻止提交</li>
</ul>
</li>
<li>onreset：重置按钮被点击</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>二分图最大匹配</title>
    <url>/2020/05/13/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>一张图$G$是<strong>二分图</strong>当且仅当G的点集$V$可以分为两个点集$V_0,V_1$，满足$V_0\cup V_1=V$,$V_0\cap V_1=\varnothing$且对于$G$的每条边$e$，其两个端点分别属于不同的点集。</li>
<li>图$G$的一个匹配是$G$的一个边集$E_0$满足$E_0$中的所有边都没有公共端点</li>
</ul>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>复杂度$O(ne+m)$<br>遍历每个左点</p>
<ul>
<li>右点未分配，那便分配</li>
<li>已经分配，dfs右点，将右点的点抢回来</li>
<li>重新分配右点，如果右点找不到新的，那就抢不回来，找得到，抢的回来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,e,ans,vis[N],mat[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;vi&gt;g(N);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; e;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u,v;e;--e)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">        g[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(i,i))</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> tag)</span></span>&#123; <span class="comment">//tag的作用是让找不到的时候递归，但不能返回u这个点</span></span><br><span class="line">    <span class="keyword">if</span>(vis[u]==tag)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vis[u]=tag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:g[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(mat[x]==<span class="number">0</span>||dfs(mat[x],tag))&#123;</span><br><span class="line">            mat[x]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dinic算法"><a href="#dinic算法" class="headerlink" title="dinic算法"></a>dinic算法</h2><p>复杂度$O(n\sqrt{e})$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>图</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2020/02/06/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>全排列是指对一个字符串或者数字或者其他任何可以排序的类型的元素数组的重新排列的所有情况</p>
<p>实现方法: 先把该数组排序，然后bfs搜索所有可能<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="built_in">string</span> a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 最终情况及操作</span></span><br><span class="line">    <span class="keyword">if</span> (l == r)  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 全排列模板 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            swap(a[l], a[i]);  </span><br><span class="line">            permute(a, l+<span class="number">1</span>, r);  </span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            swap(a[l], a[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="c-标准库函数"><a href="#c-标准库函数" class="headerlink" title="c++标准库函数"></a>c++标准库函数</h2><p>在algorithm库中的next_permutation(start,end,cmp)，返回bool，中间进行对数组的变形</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//操作</span></span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(a,a+n,cmp));</span><br></pre></td></tr></table></figure>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://vjudge.net/problem/POJ-1256" target="_blank" rel="noopener"><strong>描述</strong></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> ch[maxn];</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">toU</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="comment">//转换至大写字母</span></span><br><span class="line">	<span class="keyword">if</span>(c &gt;= <span class="string">'a'</span>)<span class="keyword">return</span> c - <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> c1,<span class="keyword">char</span> c2)</span></span>&#123;<span class="comment">//比较函数</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="string">'a'</span>&lt;=c1 &amp;&amp; c2&gt;=<span class="string">'a'</span> &amp;&amp; c1 &gt;= <span class="string">'A'</span> &amp;&amp; c2 &lt;= <span class="string">'Z'</span>) || <span class="built_in">abs</span>(c1-c2) == <span class="number">32</span>)		<span class="keyword">return</span> c1 &lt; c2;</span><br><span class="line">	<span class="keyword">return</span> toU(c1) &lt; toU(c2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</span><br><span class="line">		<span class="keyword">int</span> clen = <span class="built_in">strlen</span>(ch);</span><br><span class="line">		sort(ch,ch+clen,cmp);</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ch);</span><br><span class="line">		&#125;<span class="keyword">while</span>(next_permutation(ch,ch+clen,cmp));<span class="comment">//全排列函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增LCA</title>
    <url>/2020/05/03/%E5%80%8D%E5%A2%9ELCA/</url>
    <content><![CDATA[<p>LCA是指求最近公共祖先的算法，如果使用暴力，那就是从下至上，但肯定会爆RE<br>使用倍增优化后，复杂度nlogn<br>步骤：</p>
<ul>
<li>初始化<ul>
<li>数据输入</li>
<li>lg优化(初始化lg[i]=log2(i)+1)</li>
<li>dfs初始化fa[i][j]=i节点的2^j祖先</li>
</ul>
</li>
<li>LCA<ul>
<li>将a,b的深度调为一致</li>
<li>如果相同，返回该祖先</li>
<li>如果不同<ul>
<li>i = lg(a)-1 -&gt; 0,i 为 倍增的倍数</li>
<li>如果fa[a][i] != fa[b][i]向上调节，逐渐到LCA的儿子节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,cnt,head[maxn&lt;&lt;<span class="number">1</span>],nxt[maxn&lt;&lt;<span class="number">1</span>],depth[maxn],lg[maxn],fa[maxn][<span class="number">20</span>],to[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 添加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	nxt[++cnt] = head[u];</span><br><span class="line">	to[cnt] = v;</span><br><span class="line">	head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> fu)</span></span>&#123;</span><br><span class="line">	fa[cur][<span class="number">0</span>] = fu,depth[cur] = depth[fu] + <span class="number">1</span>;</span><br><span class="line">	rep(i,<span class="number">1</span>,lg[depth[cur]<span class="number">-1</span>])&#123;</span><br><span class="line">		fa[cur][i] = fa[fa[cur][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(reg <span class="keyword">int</span> i = head[cur];i;i = nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i] != fu)dfs(to[i],cur);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LCA</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[a] &lt; depth[b])swap(a,b);</span><br><span class="line">	<span class="keyword">while</span>(depth[a] &gt; depth[b])&#123;</span><br><span class="line">		a = fa[a][lg[depth[a]-depth[b]]<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = lg[depth[a]]<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[a][i] != fa[b][i])a = fa[a][i],b = fa[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	reg <span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		add(x,y),add(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s,<span class="number">0</span>);</span><br><span class="line">	rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,LCA(x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title>区间dp模版</title>
    <url>/2020/04/26/%E5%8C%BA%E9%97%B4dp%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<p>区间dp是指在一个区间上进行的dp，通常有区间合并这类题目<br><a href="https://www.luogu.com.cn/problem/P1880" target="_blank" rel="noopener">原题</a><br>思路：另f[i][j]为从i到j的最大得分，d[i][j]为从i到j的总石子数，故<br>f[i][j]=max(f[i][j],f[i][k]+f[k][j]+d[i][j])<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> f1[maxn][maxn],f2[maxn][maxn],d[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f1,<span class="number">0</span>,<span class="keyword">sizeof</span>(f1));</span><br><span class="line">    <span class="built_in">memset</span>(f2,<span class="number">0</span>,<span class="keyword">sizeof</span>(f2));</span><br><span class="line">    <span class="keyword">int</span> n,N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;d[i][i];</span><br><span class="line">        d[i+n][i+n]=d[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    N = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; N;++j)&#123;</span><br><span class="line">            d[i][j]=d[i][j<span class="number">-1</span>]+d[j][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt; n;++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i+k &lt;= N;++i)&#123;</span><br><span class="line">            f2[i][i+k]=inf;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt;= i+k;++j)&#123;</span><br><span class="line">                f1[i][i+k]=<span class="built_in">max</span>(f1[i][i+k],f1[i][j<span class="number">-1</span>]+f1[j][i+k]+d[i][i+k]);</span><br><span class="line">                f2[i][i+k]=<span class="built_in">min</span>(f2[i][i+k],f2[i][j<span class="number">-1</span>]+f2[j][i+k]+d[i][i+k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a1 = inf,a2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        a1 = <span class="built_in">min</span>(a1,f2[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        a2 = <span class="built_in">max</span>(a2,f1[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; a2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单词接龙</title>
    <url>/2020/02/12/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1019" target="_blank" rel="noopener">传送门</a></p>
<p>描述：单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast和astonishastonish，如果接成一条龙则变为beastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。</p>
<p>思路：直接搜索</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &lt; b ? b :a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &lt; b ? a :b;&#125;</span><br><span class="line"><span class="keyword">int</span> n,vis[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;,ans = <span class="number">0</span>,len[<span class="number">25</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,str.length());</span><br><span class="line">    <span class="keyword">int</span> tt = str.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">min</span>(tt,len[i]) - <span class="number">1</span>,flag = <span class="number">0</span>,j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j &lt;= t;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i].substr(<span class="number">0</span>,j)==str.substr(tt - j))&#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                ++vis[i];</span><br><span class="line">                dfs(str + s[i].substr(j));</span><br><span class="line">                --vis[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">        len[i] = s[i].length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i][<span class="number">0</span>] == start)&#123;</span><br><span class="line">            ++vis[i];</span><br><span class="line">            dfs(s[i]);</span><br><span class="line">            --vis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2020/05/05/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<p>单调栈就是一个特殊的有单调性的栈，适用于求解区间后大于小于的问题<br><a href="https://www.luogu.com.cn/problem/P5788" target="_blank" rel="noopener">传送门</a><br>这题卡输入输出，故采用快读快输优化，然后使用数组模拟栈<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(reg int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(reg int i = a;i &gt;= b;--i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[maxn],top,a[maxn],f[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		a[i] = <span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	drp(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;a[st[top]]&lt;=a[i])--top;</span><br><span class="line">		f[i] = st[top];</span><br><span class="line">		st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		<span class="built_in">write</span>(f[i]),<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))f = (f&lt;&lt;<span class="number">1</span>)+(f&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c = getchar();</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">9</span>)<span class="built_in">write</span>(x/<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈概述</title>
    <url>/2020/05/17/%E5%8D%9A%E5%BC%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>博弈论(Game Theory)又称对策论，是研究具有斗争或竞争性质现象的数学理论和方法。也是运筹学的一个重要学科。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。著名的例子是囚徒困境。</p>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><ul>
<li>介绍：一堆n个物品，两人轮流取1~m个，先取完的人获胜</li>
<li>答案：如果n%(m+1)==0,第一个人必输，反之，必赢。</li>
<li>思路：如果第一个人取a个，第二个人取m+1-a个，那么永远是第二个人结尾</li>
</ul>
<h2 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h2><ul>
<li>介绍：两堆物品a,b，两个人挑，要么从一堆中至少取出一个，要么同时从两堆取出相同多的物品</li>
<li>答案：证明有点复杂，直接上代码了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = (<span class="built_in">sqrt</span>(<span class="number">5.0</span>)+<span class="number">1</span>)/<span class="number">2</span>; <span class="comment">//黄金分割比</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="built_in">abs</span>(a-b)*r;</span><br><span class="line"><span class="keyword">if</span>(d!=<span class="built_in">min</span>(a,b))<span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//第一个人会赢</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>；</span><br></pre></td></tr></table></figure>
<h2 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h2><ul>
<li>介绍：n堆物品，两人轮流取，每次取堆中至少一个，最后取完者胜。</li>
<li>结论：将n堆物品全部异或，结果为0则必败，否则必胜。</li>
<li>证明略，较为复杂</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">    res ^= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一般博弈"><a href="#一般博弈" class="headerlink" title="一般博弈"></a>一般博弈</h2><p>一般博弈不太可能是模板题，需要通过SG函数ICG模型转化为尼姆博弈再进行求解。<br>即将任何一种局面看成有向无环图的一个顶点，每个局面和它的子局面相连。<br>定义mex(集合)运算，表示最小的不属于这个集合的非负整数。<br>每个顶点的SG函数为sg(x)=mex(sg(y)|y是x的后继)<br>状态是先手的人的状态，移动是两个人的移动<br>如果某个状态是另外一个状态的子状态，那么父状态的sg值是所有子状态的sg值的异或和。<br>sg函数的求法，每个题目是不同的。</p>
<ul>
<li>寻找所有的必败态</li>
<li>找出当前所有状态的前驱节点</li>
<li>根据定义计算节点的sg值</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>南蛮图腾</title>
    <url>/2020/02/10/%E5%8D%97%E8%9B%AE%E5%9B%BE%E8%85%BE/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1498" target="_blank" rel="noopener">传送门</a></p>
<p><strong>描述：</strong>给出一个数字，输出一定规律的图腾</p>
<p><strong>思考：</strong>直接初始化一个足够大的二维数组，做盛放字符的容器，然后一步步将原规律复制到数组中。</p>
<p><strong>坑点：</strong>数组必须在主函数内部进行初始化，否则洛谷会报错，但本地运行良好。</p>
<p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">1024</span>][<span class="number">2048</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1024</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2048</span>;++j)</span><br><span class="line">		arr[i][j] = <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'/'</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">'_'</span>;</span><br><span class="line">	arr[<span class="number">0</span>][<span class="number">3</span>] = arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'\\'</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">4</span>, h = <span class="number">2</span>;<span class="comment">//where next group start copying</span></span><br><span class="line">	<span class="keyword">while</span>(--n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; h;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; l;++j)&#123;</span><br><span class="line">			arr[i + h][j + h] = arr[i][j + l] = arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		h &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = h - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; l;++j)&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>台阶问题</title>
    <url>/2020/02/13/%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>台阶问题是指到达第n个台阶，每部最多走k步的问题，如果dfs必然超标，只能dp<br>规律发现，k个以内的台阶，每次都是上面一步的两倍<br>k个以外的台阶，每次都是上次的两倍减去f[i-k-1]<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,f[<span class="number">100001</span>],n,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>]  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= k)f[i] = <span class="number">2</span>*f[i - <span class="number">1</span>] %mod;</span><br><span class="line">        <span class="keyword">else</span> f[i] = (<span class="number">2</span>*f[i<span class="number">-1</span>]-f[i-k<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (f[n]+mod)%mod &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>发现环</title>
    <url>/2020/05/15/%E5%8F%91%E7%8E%B0%E7%8E%AF/</url>
    <content><![CDATA[<ul>
<li><a href="http://lx.lanqiao.cn/problem.page?gpid=T452" target="_blank" rel="noopener">来源</a></li>
<li>描述：一棵树，求其中包含的一个环，并输出所有环上的点</li>
<li>思路：是tarjan缩点的一个变式<ul>
<li>初始化一个栈</li>
<li>dfs这棵树<ul>
<li>首先把开始的元素放入栈中</li>
<li>判断是否已经放入</li>
<li>如果放入，那么说明成环</li>
<li>回退直到碰到相同点，这些都是答案</li>
</ul>
</li>
<li>如果没有找到，那么把这些元素直到dfs的根元素退栈</li>
<li>注意这是双向图，那么dfs的时候不能回到父节点，所以要特判一下有没有这个特殊情况</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> par pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;par&gt;s;</span><br><span class="line"><span class="keyword">int</span> n,f1,f2,flag,vis[N],stac[N],cnt,ans[N],tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;fa[N],tg[N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> tag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,a,b;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">        tg[a].push_back(b);</span><br><span class="line">        tg[b].push_back(a);</span><br><span class="line">        par p(a,b),p1(b,a);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">find</span>(p)!=s.<span class="built_in">end</span>())&#123;                 <span class="comment">//特判父子节点成环</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(a,b) &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">max</span>(a,b);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(p),s.insert(p1);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">-1</span>);    <span class="comment">//dfs</span></span><br><span class="line">    sort(ans+<span class="number">1</span>,ans+<span class="number">1</span>+tot);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">return</span>;         <span class="comment">//已经找到答案，退出</span></span><br><span class="line">    stac[++cnt]=root;       <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">if</span>(vis[root]==<span class="number">1</span>)&#123;       <span class="comment">//发现环，输出答案</span></span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="keyword">while</span>(stac[cnt]!=root)&#123;</span><br><span class="line">            ans[++tot]=stac[cnt];</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[++tot]=root;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++vis[root];            <span class="comment">//标记元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; tg[root].<span class="built_in">size</span>();++i)&#123; <span class="comment">//深度优先遍历</span></span><br><span class="line">        <span class="keyword">int</span> x = tg[root][i];</span><br><span class="line">        <span class="keyword">if</span>(x!=tag)&#123;</span><br><span class="line">            dfs(x,root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;                      <span class="comment">//未发现环，退栈</span></span><br><span class="line">        <span class="keyword">while</span>(stac[cnt--]!=root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>基本vim命令</title>
    <url>/2020/06/06/%E5%9F%BA%E6%9C%ACvim%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>按i进入插入模式，可以插入字符</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>Press Esc to 命令模式</p>
<ul>
<li>x - to delete the unwanted character</li>
<li>u - to undo the last the command and U to undo the whole line</li>
<li>CTRL-R to redo</li>
<li>A - to append text at the end</li>
<li>:wq - to save and exit</li>
<li>:q! - to trash all changes</li>
<li>dw - move the cursor to the beginning of the word to delete that word</li>
<li>2w - to move the cursor two words forward.</li>
<li>3e - to move the cursor to the end of the third word forward.</li>
<li>0 (zero) to move to the start of the line.</li>
<li>d2w - which deletes 2 words .. number can be changed for deleting the number of consecutive * words like d3w</li>
<li>dd to delete the line and 2dd to delete to line .number can be changed for deleting the number of consecutive words</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>各种常数优化</title>
    <url>/2020/04/27/%E5%90%84%E7%A7%8D%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pf printf</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">12</span>], *p1, *p2;</span><br><span class="line">    <span class="keyword">return</span> (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">1</span> &lt;&lt; <span class="number">12</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, sym = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getc();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">            sym = <span class="number">-1</span>;</span><br><span class="line">        c = getc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="number">48</span>;</span><br><span class="line">        c = getc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * sym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>大组合数取模</title>
    <url>/2020/04/21/%E5%A4%A7%E7%BB%84%E5%90%88%E6%95%B0%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>一般的组合数可以使用常规的递归得到，但是大组合数取模的复杂度太大，可以使用lucas定理进行优化;<br><a href="https://www.luogu.com.cn/problem/P3807" target="_blank" rel="noopener">原题</a><br>假设组合数函数为C(n,m) p为模数,fac(n)为阶乘函数<br>那么$C_n^m\%p = C_{n/p}^{m/p}<em>C_{n\%p}^{m\%p}\%p$<br>其中，第一项接着lucas递归，第二项直接求解<br>ie.直接求解时可以使用逆元运算，避免除数，即$C_n^m=n!</em>m^{p-2}*{(n-m)}^{p-2}\%p$</p>
<pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
#define ll long long
const ll maxn = 1e5+5;
using namespace std;
ll f[maxn],p;
ll lucas(ll n,ll m);
ll C(ll n,ll m);
ll qpow(ll n,ll m);
int main(){
    //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
    ll T,a,b;
    cin&gt;&gt;T;
    while(T--){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;
        f[0]=1;
        for(ll i = 1;i &lt;= p;++i)f[i]=i*f[i-1]%p;
        cout&lt;&lt;lucas(a+b,a)&lt;&lt;endl;
    }
    return 0;
}
ll qpow(ll n,ll m){
    ll ans = 1;
    for(int i = m;i;i&gt;&gt;=1,n=n*n%p){
        if(i&amp;1)ans = ans * n % p;
    }
    return ans;
};
ll C(ll n,ll m){
    if(m&gt;n)return 0;
    return f[n]*qpow(f[m],p-2)%p*qpow(f[n-m],p-2)%p;
};
ll lucas(ll n,ll m){
    if(m==0)return 1;
    return lucas(n/p,m/p)*C(n%p,m%p)%p;
};
</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>基础的ubuntu命令</title>
    <url>/2020/05/28/%E5%9F%BA%E7%A1%80%E7%9A%84ubuntu%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li>sudo(SuperUser DO) 让你拥有管理员权限</li>
<li>apt(Advanced Packaged Tool) 管理包的工具<ul>
<li>apt update 更新源</li>
<li>apt upgrade 更新软件</li>
<li>apt install &lt; package &gt; 安装软件</li>
<li>apt remove &lt; package &gt; 卸载软件</li>
<li>apt purge &lt; package &gt; 卸载软件并且删掉个人配置</li>
<li>apt autoremove 删除不需要的依赖文件</li>
</ul>
</li>
<li>ls(list) 列出当前目录下的文件</li>
<li>cd(change director) 修改目录 cd ~,cd /</li>
<li>pwd(print working directory) 打印工作目录</li>
<li>cp(copy) 复制文件到另一目录 cp x y</li>
<li>mv(move) 移动文件到另一目录 mv x y</li>
<li>rm(remove) 删除特定文件</li>
<li>rmdir  删除文件夹</li>
<li>mkdir(make directory) 创作文件夹</li>
<li>history 历史命令</li>
<li>df(display filesystem) 展示磁盘中空间的使用情况</li>
<li>du(directory usage) 展示目录大小</li>
<li>free 展示系统中空余的容量</li>
<li>uname -a 展示系统的基本信息</li>
<li>top 展示系统中使用最多系统资源的进程，按q结束</li>
<li>man 展示命令使用手册<ul>
<li>man man 展示man命令如何使用</li>
<li>man intro 展示linux命令的一个简短的介绍</li>
</ul>
</li>
<li>info 与man命令类似，但提供更详细的信息</li>
<li>&lt; command &gt; -h 展示某个命令的使用帮助</li>
<li>passwd 改密码 pwsswd &lt; user &gt;</li>
<li>whatis 简短的展示某个命令的作用 whatis cp </li>
<li>netstat  -anp  |grep 端口号 查看端口占用</li>
<li>iptables -t nat -A PREROUTING -p tcp —dport 7777 -j REDIRECT —to-port 6666 端口从7777转发到6666</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>尺取法</title>
    <url>/2020/08/19/%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<p>尺取法就是在一个线性序列中，求满足某一条件的最优的一段序列，那么这个序列就是有左界和右界，而且最优解是关于左界和右界是单调的，于是可以在O(n)时间范围内解决这个问题，右界加一或者左界加一。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>最短路模版</title>
    <url>/2020/02/14/%E5%A0%86%E4%BC%98%E5%8C%96%E7%9A%84Dijkstra/</url>
    <content><![CDATA[<ul>
<li>显然，就是一个模版，求从src点到其他所有点的最短路</li>
<li>原题链接：<a href="https://www.luogu.com.cn/problem/P3371" target="_blank" rel="noopener">传送门</a>*</li>
</ul>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA是队列为数据结构的算法 复杂度为O(VE) 很容易被卡 一般遇到负边权的情况下 给每个边加一个边权 就可以使用dijkstra可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ipar pair<span class="meta-string">&lt;char,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uit unsigned int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,a,b) for(int i = a;i &lt; b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a&lt;b?b:a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ABS(a) (a&lt;0?-a:a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>,M = <span class="number">5e5</span>+<span class="number">5</span>,MOD=<span class="number">998244353</span>,inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,hd[M],cnt,vis[N],dis[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,nxt;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    e[cnt].nxt = hd[u];</span><br><span class="line">    hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u,v,w,i = m;i;--i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        add(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="built_in">fill</span>(dis,dis+n+<span class="number">1</span>,inf);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[u];i;i = e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u]+w)&#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,dis[i],i==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ipair; <span class="comment">//第一个是点，第二个是权重</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;ipair&gt; adj[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn],vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t1,t2,t3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ipair,<span class="built_in">vector</span>&lt;ipair&gt;,greater&lt;ipair&gt; &gt; pq;</span><br><span class="line">    <span class="built_in">fill</span>(dist,dist+maxn,inf);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    pq.push(make_pair(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        adj[t1].push_back(make_pair(t2,t3));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:adj[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = x.first;</span><br><span class="line">            <span class="keyword">int</span> w = x.second;</span><br><span class="line">            <span class="keyword">if</span>(dist[v] &gt; dist[u] + w)&#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pq.push(make_pair(dist[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] != inf)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dist[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="number">0x7fffffff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>大数加减乘除</title>
    <url>/2020/07/30/%E5%A4%A7%E6%95%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<ul>
<li>借助数组实现大数的加减乘除</li>
<li>浓缩在一个结构体里，利于debug</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matric</span>&#123;</span></span><br><span class="line">	<span class="comment">//a为存储大数的数组，低位对应的也是数的低位 </span></span><br><span class="line">	<span class="comment">//cnt为位数</span></span><br><span class="line">	<span class="comment">//flag为1代表正数，为-1代表负数 </span></span><br><span class="line">	<span class="keyword">int</span> a[N],cnt,flag;</span><br><span class="line">	Matric()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">		cnt = <span class="number">1</span>;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Matric <span class="keyword">operator</span> +(Matric m)<span class="keyword">const</span>&#123;</span><br><span class="line">		Matric t;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">0</span>,MAX(m.cnt,cnt)<span class="number">-1</span>)&#123;</span><br><span class="line">			t.a[i]=m.a[i]+a[i]+k;</span><br><span class="line">			k = t.a[i]/<span class="number">10</span>;</span><br><span class="line">			t.a[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t.cnt=MAX(m.cnt,cnt);</span><br><span class="line">		<span class="keyword">if</span>(k)&#123;</span><br><span class="line">			t.a[t.cnt]=k;</span><br><span class="line">			t.cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	Matric <span class="keyword">operator</span> -(Matric m)<span class="keyword">const</span>&#123;</span><br><span class="line">		Matric t;</span><br><span class="line">		<span class="keyword">int</span> mx = MAX(m.cnt,cnt);</span><br><span class="line">		drp(i,mx<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]!=m.a[i])&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]&lt;m.a[i])&#123;</span><br><span class="line">					t.flag = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rep(i,<span class="number">0</span>,mx<span class="number">-1</span>)&#123;</span><br><span class="line">			t.a[i] += t.flag*(a[i]-m.a[i]);</span><br><span class="line">			<span class="keyword">if</span>(t.a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				t.a[i+<span class="number">1</span>]--;</span><br><span class="line">				t.a[i]+=<span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t.cnt = mx;</span><br><span class="line">		<span class="keyword">while</span>(t.a[t.cnt<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;t.cnt&gt;=<span class="number">2</span>)--t.cnt;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125; </span><br><span class="line">	Matric <span class="keyword">operator</span> *(Matric m)&#123;</span><br><span class="line">		Matric t;</span><br><span class="line">        <span class="comment">// 处理当某个式子为0时的情况</span></span><br><span class="line">        <span class="comment">// 如果题目要求有负数时，可以用flag判定一下还是正数的乘法</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">1</span>&amp;&amp;a[<span class="number">0</span>]==<span class="number">0</span>||m.cnt==<span class="number">1</span>&amp;&amp;m.a[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">0</span>,cnt<span class="number">-1</span>)&#123;</span><br><span class="line">			rep(j,<span class="number">0</span>,m.cnt<span class="number">-1</span>)&#123;</span><br><span class="line">				t.a[i+j]+=a[i]*m.a[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		t.cnt = cnt+m.cnt<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t.cnt==<span class="number">0</span>)t.cnt = <span class="number">1</span>; </span><br><span class="line">		rep(i,<span class="number">0</span>,t.cnt<span class="number">-1</span>)&#123;</span><br><span class="line">            t.a[i]+=k;</span><br><span class="line">			k = t.a[i]/<span class="number">10</span>;</span><br><span class="line">			t.a[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(k)&#123;</span><br><span class="line">			t.a[t.cnt++]=k%<span class="number">10</span>;</span><br><span class="line">			k/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">    Matric <span class="keyword">operator</span> /(ll m)<span class="keyword">const</span>&#123;</span><br><span class="line">        Matric t;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        drp(i,cnt<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">            ll p = k*<span class="number">10</span>+a[i];</span><br><span class="line">            t.a[i] = p/m;</span><br><span class="line">            k = p%m;</span><br><span class="line">        &#125;</span><br><span class="line">        t.cnt = cnt;</span><br><span class="line">        <span class="keyword">while</span>(t.cnt&gt;=<span class="number">1</span>&amp;&amp;t.a[t.cnt<span class="number">-1</span>]==<span class="number">0</span>)--t.cnt;</span><br><span class="line">        <span class="keyword">if</span>(t.cnt==<span class="number">0</span>)t.cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式系统及应用</title>
    <url>/2020/02/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="嵌入式系统概述"><a href="#嵌入式系统概述" class="headerlink" title="嵌入式系统概述"></a>嵌入式系统概述</h2><ul>
<li>定义：应用为中心，以计算机技术为基础，软硬件可按照需求进行定制，从而满足 特 定 功能、性能、成本、体积和功耗等设计指标。</li>
</ul>
<h3 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h3><p><img src="嵌入式架构.png" alt=""><br><img src="计算机体系架构.png" alt=""></p>
<h3 id="嵌入式微处理器"><a href="#嵌入式微处理器" class="headerlink" title="嵌入式微处理器"></a>嵌入式微处理器</h3><p>• 嵌入式硬件系统的核心是嵌入式处理器，它的选择取决于具体应用的领域，处理能力和接口要求，以及成本、功耗等限制。<br>• 嵌入式处理器可分为嵌入式微控制器（EmbeddedMicro Controller Unit，EMCU）和高度集成的嵌入式片上系统（System On Chip，SOC）。</p>
<h3 id="通用处理器与微控制器的不同"><a href="#通用处理器与微控制器的不同" class="headerlink" title="通用处理器与微控制器的不同"></a>通用处理器与微控制器的不同</h3><ul>
<li>微处理器更多指处理器的部分，即CPU，而微控制器还包含了内存，存储单元（flash),定时器，DMA，和其他一些接口，可以视为一个片上计算机，也被称为单片机。</li>
</ul>
<h3 id="总线、外部设备接口"><a href="#总线、外部设备接口" class="headerlink" title="总线、外部设备接口"></a>总线、外部设备接口</h3><p>嵌入式系统根据具体的应用，配置不同的外围设备或者子系统，并通过总线、外部<br>设备接口进行通信。总线以一种通用的方式为各组件提供数据传送和控制逻辑<br>    （1）串行通信接口：RS-232、I2C、SPI等；<br>    （2）USB接口；<br>    （3）多媒体卡接口：SD卡、CF卡等；<br>    （4）网络接口：包括有线和无线网络等；<br>    （5）GPIO、模数/数模转换(ADC/DAC)接口；</p>
<h3 id="嵌入式软件"><a href="#嵌入式软件" class="headerlink" title="嵌入式软件"></a>嵌入式软件</h3><p>• 嵌入式软件是实现系统功能和应用的关键。<br>• 嵌入式应用程序利用驱动直接运行于硬件平台之上。<br>• 随着对实时性要求的提高，以及软硬件资源规模不断上升，嵌入式系统的开发人员开始使用嵌入式操作系统编写嵌入式应用软件。<br>• 嵌入式操作系统可以缩短开发周期，提高开发效率。扩大了嵌入式系统的应用空间。</p>
<h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>• 基于单片机的应用，一般没有操作系统的支持，只能通过汇编语言对硬件系统进行直接控制。<br>• 随着实时性要求的提高和软件规模也不断扩大，逐渐形成了实时多任务操作系统（RTOS），并开始成为嵌入式系统的主流。<br>• RTOS操作系统能够运行在各种不同类型的微处理器上，具有高度的可移植性、模块化和扩展性。并具备了文件和目录管理、设备管理、多任务、网络、图形用户界面（GUI）等功能。<br>• 嵌入式操作系统大部分采用抢占式调度机制，响应时间短，内核可裁剪，可移植性强。</p>
]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/04/27/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p><strong>root(a):找到a点的根</strong><br><strong>joint(a,b):联合a、b点</strong></p>
<p><strong>双重优化</strong></p>
<ul>
<li>整合了树的高度</li>
<li>联合时把小树连到大树上<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(id[a] != a)&#123;</span><br><span class="line">        id[a] = id[id[a]];</span><br><span class="line">        a = id[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joint</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ra = root(a),rb = root(b);</span><br><span class="line">    <span class="keyword">if</span>(sz[ra]&lt;sz[rb])&#123;</span><br><span class="line">        id[ra] = rb;</span><br><span class="line">        sz[rb] += sz[ra];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        id[rb] = ra;</span><br><span class="line">        sz[ra] += sz[rb];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>对局匹配</title>
    <url>/2020/02/01/%E5%AF%B9%E5%B1%80%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><a href="http://lx.lanqiao.cn/problem.page?gpid=T454" target="_blank" rel="noopener">Description</a><br>很常见的动态规划题目，分成K组，每组用动态规划求最大不相邻子数组值，再求和<br>也就是说，把整个要处理的数据分组再各自dp并将分组的值求和<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">100005</span>],a[<span class="number">100005</span>],dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n,k,t,x=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">        book[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">100005</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (book[i]!=<span class="number">0</span>)</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            x=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&lt;<span class="number">100005</span>;j+=k)	<span class="comment">//核心代码，将数据分组，各自dp再求和</span></span><br><span class="line">            	a[x++]=book[j];</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;x;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">0</span>)</span><br><span class="line">                dp[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">1</span>)</span><br><span class="line">                dp[<span class="number">1</span>]=<span class="built_in">max</span>(a[<span class="number">1</span>],dp[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j<span class="number">-1</span>],dp[j<span class="number">-2</span>]+a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=dp[x<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂取余</title>
    <url>/2020/02/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E4%BD%99/</url>
    <content><![CDATA[<p>问题：a^b%c的答案是多少</p>
<p>原理：<br>    如果b为偶数,a^b%c=(a*a%c)^(b/2)%c<br>    如果b为奇数,a^b%c=(a*a%c)^(b/2)*a%c</p>
<p>算法：<br>    一步步迭代，每次更新a和b，如果b为奇数，那么分离奇数项，乘进ans取余</p>
<p>c++代码(复杂度为log(b)，稳定快速)：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">			ans = ans * a % c;</span><br><span class="line">		&#125;</span><br><span class="line">		a = a * a % c;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2020-1-21更新"><a href="#2020-1-21更新" class="headerlink" title="2020/1/21更新"></a>2020/1/21更新</h2><p>这是快速幂的模板，很多时候一些问题也可以转换到这个方向上求解，例如序列上涂偶数色问题，可以先将奇数色转变为偶数，然后是每位×颜色数的问题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2020/05/07/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>差分就是类似于d = a[i] - a[i-1]<br>可以解决区间和的问题<br><a href="https://www.luogu.com.cn/problem/P3397" target="_blank" rel="noopener">传送门</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> md(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,p[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="comment">//核心代码，前面加一，后面减一，累计相加达到目的</span></span><br><span class="line">		rep(i,x1,x2)&#123;</span><br><span class="line">			p[i][y1][<span class="number">0</span>] += <span class="number">1</span>,p[i][y2][<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j)&#123;</span><br><span class="line">			sum += p[i][j][<span class="number">0</span>];</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">			<span class="keyword">if</span>(j!=n)<span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">			sum += p[i][j][<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>尼克的任务</title>
    <url>/2020/02/21/%E5%B0%BC%E5%85%8B%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1280" target="_blank" rel="noopener">传送门</a></p>
<p>思路：从后往前dp</p>
<ul>
<li>如果当前时刻空闲，那么dp[i]=dp[i+1]+1</li>
<li>如果此刻有任务发布，那么dp[i] = max(dp[i],dp[i+time]);</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,dp[maxn],t1,t2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;t1,&amp;t2);</span><br><span class="line">		v[t1].push_back(t2);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;--i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[i].empty())dp[i]=dp[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; v[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i],dp[i+v[i][j]]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里得</title>
    <url>/2020/02/22/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    <content><![CDATA[<h2 id="欧几里得算法可以求a-b的最大公因数gcd-a-b"><a href="#欧几里得算法可以求a-b的最大公因数gcd-a-b" class="headerlink" title="欧几里得算法可以求a,b的最大公因数gcd(a,b)"></a>欧几里得算法可以求a,b的最大公因数gcd(a,b)</h2><p>原理：铺瓷砖问题，假设a &lt; b,先铺a边长的瓷砖，直到铺不下去，然后换一边接着铺，直到铺满，最小正方形边长即是最大公约数。</p>
<p>更数学的解释在下面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b)<span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展欧几里得既可以求得最大公因数，还可以求得x-y"><a href="#扩展欧几里得既可以求得最大公因数，还可以求得x-y" class="headerlink" title="扩展欧几里得既可以求得最大公因数，还可以求得x,y"></a>扩展欧几里得既可以求得最大公因数，还可以求得x,y</h2><p>满足ax+by=gcd(a,b)</p>
<p>原理：由<strong>贝祖定理</strong>给出，给定二个整数a、b，必存在整数x、y使得ax + by = gcd(a,b)</p>
<script type="math/tex; mode=display">
\because ax+by=gcd(a,b)\\
\because gcd(a,b)=gcd(b,a\%b)\\
\therefore ax+by=bx'+(a\%b)y'=bx'+(a-a/b*b)y'=ay'+b(x'-a/b*y')\\
\therefore x=y',y=x'-a/b*y'\\</script><p>根据这个关系进行递归，所以得出相应的x和y<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">if</span>(b)&#123;</span><br><span class="line">		res = exgcd(b,a%b,x,y);</span><br><span class="line">		<span class="keyword">int</span> t = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = t - (a/b*y);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		res = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>扩展欧几里得在gcd==1时特别有用，尤其在RSA加密算法中使用很多。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/08/14/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = low - <span class="number">1</span>,j = low;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[high];</span><br><span class="line">	<span class="keyword">for</span>(;j &lt; high;++j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[j] &lt; pivot)&#123;</span><br><span class="line">			++i;</span><br><span class="line">			swap(&amp;arr[i],&amp;arr[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(arr[i+<span class="number">1</span>],arr[high]);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">int</span> poi = partition(arr,low,high);</span><br><span class="line">		quickSort(arr,low,poi<span class="number">-1</span>);</span><br><span class="line">		quickSort(arr,poi+<span class="number">1</span>,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = low,j = mid + <span class="number">1</span>,k = low;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &lt; a[j])r[k] = a[i],++i;</span><br><span class="line">		<span class="keyword">else</span> r[k] = a[j],++j;</span><br><span class="line">		++k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid)r[k++] = a[i++];</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= high)r[k++] = a[j++];</span><br><span class="line">	<span class="keyword">while</span>(low &lt;= high)a[low] = r[low],++low; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">		msort(a,low,mid);</span><br><span class="line">		msort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">		merge(a,low,high,mid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> poi)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = poi;</span><br><span class="line">	<span class="keyword">if</span>(poi&lt;&lt;<span class="number">1</span> &lt;= n &amp;&amp; a[poi&lt;&lt;<span class="number">1</span>] &gt; a[t])t = poi&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((poi&lt;&lt;<span class="number">1</span>|<span class="number">1</span>) &lt;= n &amp;&amp; a[poi*<span class="number">2</span>+<span class="number">1</span>] &gt; a[t]) t = poi&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t != poi) &#123;</span><br><span class="line">		swap(a[t],a[poi]);</span><br><span class="line">		heapify(a,n,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>;i;--i)&#123;</span><br><span class="line">		heapify(a,n,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i &gt;= <span class="number">2</span>;--i)&#123;</span><br><span class="line">		swap(a[<span class="number">1</span>],a[i]);</span><br><span class="line">		heapify(a,i - <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/05/02/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>以下介绍两种：Prim和Kruskal</p>
<p><strong>Prim</strong><br>Prim适用于稠密图，堆优化后复杂度VlogV<br>主要步骤：</p>
<pre><code>* 随意取一条边
* 将这条边相邻的边加进来
* 取一个最小的边
* 直到有n-1条边
</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IL inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="function">IL <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=-f;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();&#125;x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,tot,cnt,ans;</span><br><span class="line"><span class="keyword">int</span> first[maxn],vis[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nextx,to,val;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].nextx=first[u];</span><br><span class="line">    first[u]=tot;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].val=w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.push(M(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()&amp;&amp;cnt&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=Q.top().second;</span><br><span class="line">        <span class="keyword">int</span> w=Q.top().first;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[now])<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        ans+=w;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=first[now];i;i=e[i].nextx)</span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i].to])</span><br><span class="line">                Q.push(M(-e[i].val,e[i].to));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">read</span>(a),<span class="built_in">read</span>(b),<span class="built_in">read</span>(c);</span><br><span class="line">        add(a,b,c),add(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;prim();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Kruskal</strong><br>Kruskal适用于稀疏图<br>主要步骤：</p>
<pre><code>* 将边排序
* 取最短边
* 查看是否连通
* 不连通就加进来，连通就跳过
* 继续取最短边，直到达到n - 1条
</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(x, a, b) for (reg int x = a; x &gt;= b; --x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Min(a,b)(a&lt;b?a:b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> id[maxn],sz[maxn],n,m,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(a!=id[a])&#123;</span><br><span class="line">		id[a]=id[id[a]];</span><br><span class="line">		a = id[a];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = root(a),q = root(b);</span><br><span class="line">	<span class="keyword">if</span>(p!=q)&#123;</span><br><span class="line">		<span class="keyword">if</span>(sz[p] &lt; sz[q])&#123;</span><br><span class="line">			id[p]=q,sz[q]+=sz[p];</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			id[q]=p,sz[p]+=sz[q];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge e1,Edge e2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e1.w &lt; e2.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		id[i] = i;</span><br><span class="line">		sz[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rep(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(e+<span class="number">1</span>,e+<span class="number">1</span>+m,cmp);</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	rep(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			++t;</span><br><span class="line">			<span class="keyword">if</span>(root(e[t].u)!=root(e[t].v))&#123;</span><br><span class="line">				ans += e[t].w;</span><br><span class="line">				add(e[t].u,e[t].v);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">while</span>(t &lt;= m);</span><br><span class="line">		<span class="keyword">if</span>(t &gt; m)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"orz"</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/05/08/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<ul>
<li>介绍：拓扑排序是指在一个有向无环图中求一条线性路径，使得任意一条边<u,v>在路径上都有u在v前面</li>
<li>步骤：<ul>
<li>根据入度放入队列中</li>
<li>pop出入度为0的点，并将它的相邻点的入度减一</li>
<li>直到所有的边都出来<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v[N];</span><br><span class="line"><span class="keyword">int</span> ins[N],ans[N],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;pq;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ins[i])pq.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = pq.top()</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];i;i = nxt[i])&#123;</span><br><span class="line">            ins[to[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(!ins[to[i]])pq.push(to[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>强连通分量的分解</title>
    <url>/2020/05/27/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>强连通(SCC,Srtongly comnected component)图：一个图中，若任意两个顶点u，v，都能找到一条从u到v的路径，而且添加任何一个点，这个图都不再是一个强连通图。</li>
<li>强连通分量的分解：将一个完整的图分解为若干个强连通子图，并且，每个图缩成一个点，形成一个DAG(有向无环图)。</li>
<li>解法： tarjan和korasaju算法</li>
</ul>
<h2 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan"></a>tarjan</h2><p><a href="https://www.luogu.com.cn/problem/P3387" target="_blank" rel="noopener">传送门</a></p>
<ul>
<li>题意：一个DAG图，求一条权重最大边，可以重复走，但不能重复计算</li>
<li>思路：tarjan求出强连通子图，再遍历原图，建一个新图，然后在新图的基础上作拓扑dp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span>+<span class="number">5</span>,M = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[M],id[N],p[N],dfn[N],low[N],vis[N],stac[N];</span><br><span class="line"><span class="keyword">int</span> in[N],h[M],len[N];</span><br><span class="line"><span class="keyword">int</span> cnt,tot,top,al,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MIN</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?b:a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,nxt;</span><br><span class="line">&#125;e1[M],e2[M];       <span class="comment">//e1是建图时的边，e2是缩点之后的边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e1[++cnt].nxt = head[u];</span><br><span class="line">    e1[cnt].from = u;</span><br><span class="line">    e1[cnt].to = v;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan缩点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//关键的两行代码</span></span><br><span class="line">    dfn[x] = low[x] = ++tot;    <span class="comment">//标记x点的时间戳</span></span><br><span class="line">    vis[x] = <span class="number">1</span>;stac[++top] = x; <span class="comment">//入栈并且标记一下</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = e1[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = e1[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[x] = MIN(low[x],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">            low[x] = MIN(low[x],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当该点最低达到的点就是本身的时候，可以出栈，直到本身</span></span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])&#123; </span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="comment">//解除标记并且添加导向以完成后面的连通,添加x点权重</span></span><br><span class="line">        <span class="keyword">while</span>(t = stac[top--])&#123;</span><br><span class="line">            vis[t] = <span class="number">0</span>;</span><br><span class="line">            id[t] = x;</span><br><span class="line">            <span class="keyword">if</span>(t==x)<span class="keyword">break</span>;</span><br><span class="line">            p[x] += p[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不用保证这是一个连通图，因为从一开始就把所有入度为0的点加进去，所以每个单独的图都计算在内</span></span><br><span class="line"><span class="comment">//而且更妙的是，只是更新相邻节点的值，相当于一个bfs吧</span></span><br><span class="line"><span class="comment">//如果没用过并且入度减到了0，那么加到队列里去</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i] &amp;&amp; id[i]==i)&#123; <span class="comment">//入度为0并且本身即一个源点的时候</span></span><br><span class="line">            q.push(i);</span><br><span class="line">            len[i] = p[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u];i;i = e2[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e2[i].to;</span><br><span class="line">            len[v] = MAX(len[v],len[u]+p[v]);</span><br><span class="line">            --in[v];</span><br><span class="line">            <span class="keyword">if</span>(!in[v])q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        ans = MAX(ans,len[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u,v;m;--m)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">        addEdge(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])tarjan(i);   </span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = id[e1[i].from],v = id[e1[i].to];</span><br><span class="line">        <span class="keyword">if</span>(u != v)&#123;</span><br><span class="line">            e2[++al].nxt = h[u];</span><br><span class="line">            e2[al].from = u;</span><br><span class="line">            e2[al].to = v;</span><br><span class="line">            h[u] = al;</span><br><span class="line">            in[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,topo());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="korasaju"><a href="#korasaju" class="headerlink" title="korasaju"></a>korasaju</h2><p>两次dfs</p>
<ul>
<li>第一次后序dfs得到一个图的拓扑序，按出现的后先，越后面越先出现，存入v1中</li>
<li>第二次根据v1的点序，从后遍历，每次得到一个强连通子图<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g1[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs1(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v1.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:g2[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            dfs2(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数楼梯</title>
    <url>/2020/02/16/%E6%95%B0%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>走楼梯要么走一步，要么走两步，n个台阶，有多少种可能？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,len=<span class="number">1</span>,f[<span class="number">5003</span>][<span class="number">5003</span>];<span class="comment">//f[k][i]--第k阶台阶所对应的走法数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hp</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//高精度加法，k来存阶数 </span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">     f[k][i]=f[k<span class="number">-1</span>][i]+f[k<span class="number">-2</span>][i];<span class="comment">//套用公式 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)             <span class="comment">//进位 </span></span><br><span class="line">     <span class="keyword">if</span>(f[k][i]&gt;=<span class="number">10</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         f[k][i+<span class="number">1</span>]+=f[k][i]/<span class="number">10</span>;</span><br><span class="line">         f[k][i]=f[k][i]%<span class="number">10</span>;</span><br><span class="line">         <span class="keyword">if</span>(f[k][len+<span class="number">1</span>])len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; f[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;         <span class="comment">//初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;i++)              <span class="comment">//从3开始避免越界 </span></span><br><span class="line">     hp(i);                         </span><br><span class="line">    <span class="keyword">for</span>(i=len;i&gt;=<span class="number">1</span>;i--)             <span class="comment">//逆序输出 </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[n][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>高精加</tag>
      </tags>
  </entry>
  <entry>
    <title>最小费用流</title>
    <url>/2020/08/27/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
    <content><![CDATA[<ul>
<li>问题描述：在一个有向图中，从s到t有F单位的流量，使得通过这些流量花费的费用最小</li>
<li>思路：<ul>
<li>建有反向边的网络流图</li>
<li>使用spfa寻找可行流</li>
<li>如果存在，则加上FLOW和对应的COST，并且更新图</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        vis[i] = pre[i] = <span class="number">0</span>,flow[i] = dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    flow[s] = inf;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hd[u];i;i = e[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(e[i].w &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u]+e[i].f)&#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].f;</span><br><span class="line">                flow[v] = MIN(flow[u],w);</span><br><span class="line">                <span class="comment">// 记录前向边和点，方便进行处理</span></span><br><span class="line">                pre[v] = u;</span><br><span class="line">                last[v] = i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[t]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"in.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u,v,w,f,i = m;i;--i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;u,&amp;v,&amp;w,&amp;f);</span><br><span class="line">        add(u,v,w,f),add(v,u,<span class="number">0</span>,-f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">        mf += flow[t];</span><br><span class="line">        mc += flow[t]*dis[t];   </span><br><span class="line">        <span class="keyword">int</span> now = t;</span><br><span class="line">        <span class="keyword">while</span>(now != s)&#123;</span><br><span class="line">            <span class="keyword">int</span> t2 = last[now];</span><br><span class="line">            e[t2].w -= flow[t],e[t2^<span class="number">1</span>].w += flow[t];</span><br><span class="line">            now = pre[now]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,mf,mc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/07/23/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="区间查询和单点修改"><a href="#区间查询和单点修改" class="headerlink" title="区间查询和单点修改"></a>区间查询和单点修改</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=N)&#123;</span><br><span class="line">		<span class="built_in">bit</span>[p] += x;</span><br><span class="line">		p += p&amp;-p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		res += <span class="built_in">bit</span>[p];</span><br><span class="line">		p -= p&amp;-p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改和单点查询"><a href="#区间修改和单点查询" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=N)&#123;</span><br><span class="line">		<span class="built_in">bit</span>[p] += x;</span><br><span class="line">		p += p&amp;-p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	add(p,x);</span><br><span class="line">	add(q+<span class="number">1</span>,-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bit</span>[i] = sum(i); <span class="comment">// 差分的思路</span></span><br></pre></td></tr></table></figure>
<h2 id="区间修改和区间查询"><a href="#区间修改和区间查询" class="headerlink" title="区间修改和区间查询"></a>区间修改和区间查询</h2><p>区间修改同上<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q = p;</span><br><span class="line">	<span class="keyword">while</span>(p&lt;=N)&#123;</span><br><span class="line">		<span class="built_in">bit</span>[p] += x;</span><br><span class="line">		bit_2[p] += x*q;	<span class="comment">// 添加的辅助数组，用于查询</span></span><br><span class="line">		p += p&amp;-p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	add(p,x),add(q+<span class="number">1</span>,-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>,x = p;</span><br><span class="line">	<span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		res += (<span class="built_in">bit</span>[p]*(x+<span class="number">1</span>)-bit_2[p])	<span class="comment">// 不一样的地方</span></span><br><span class="line">		p -= p&amp;-p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum(y)-sum(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二维空间的区间修改和单点查询"><a href="#二维空间的区间修改和单点查询" class="headerlink" title="二维空间的区间修改和单点查询"></a>二维空间的区间修改和单点查询</h2><p>与imos法类似<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = y;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">		y = t;</span><br><span class="line">		<span class="keyword">while</span>(y&lt;=n)&#123;</span><br><span class="line">			<span class="built_in">bit</span>[x][y]+=v;</span><br><span class="line">			y+=y&amp;-y;</span><br><span class="line">		&#125;</span><br><span class="line">		x+=x&amp;-x;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	add(x1,y1,v),add(x1,y2+<span class="number">1</span>,-v),add(x2+<span class="number">1</span>,y1,-v),add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = y,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		y = t;</span><br><span class="line">		<span class="keyword">while</span>(y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			res += <span class="built_in">bit</span>[x][y];</span><br><span class="line">			y-=y&amp;-y;</span><br><span class="line">		&#125;</span><br><span class="line">		x-=x&amp;-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h2><h3 id="单点修改和区间查询"><a href="#单点修改和区间查询" class="headerlink" title="单点修改和区间查询"></a>单点修改和区间查询</h3><p>与一维数组类似<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &lt;= N;i += i&amp;-i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = y;j &lt;= N;j += j&amp;-j)&#123;</span><br><span class="line">			<span class="built_in">bit</span>[i][j] += v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &gt; <span class="number">0</span>;i -= i&amp;-i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = y;j &gt; <span class="number">0</span>; j -= j&amp;-j)&#123;</span><br><span class="line">			res += <span class="built_in">bit</span>[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区间修改和单点查询-1"><a href="#区间修改和单点查询-1" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h3><p>这里同样引入差分数组<br>那么</p>
<script type="math/tex; mode=display">
修改：bit[x1][y1]+=v,bit[x2+1][y1]-=v,bit[x1][y2+1]-=v,bit[x2+1][y2+1]+=v\\
查询：a[i] = (x,y)的查分求和</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &lt;= N;i += i&amp;-i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = y;j &lt;= N;j += j&amp;-j)&#123;</span><br><span class="line">			<span class="built_in">bit</span>[i][j] += v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	add(x1,y1,v),add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,v),add(x1,y2+<span class="number">1</span>,-v),add(x2,y1+<span class="number">1</span>,-v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &gt; <span class="number">0</span>;i -= i&amp;-i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = y;j &gt; <span class="number">0</span>;j -= j&amp;-j)&#123;</span><br><span class="line">			res += <span class="built_in">bit</span>[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改和区间查询-1"><a href="#区间修改和区间查询-1" class="headerlink" title="区间修改和区间查询"></a>区间修改和区间查询</h3><p>同理，从单点查询进行推导<br>得到C1,C2,C3,C4，简单的进行加减<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;=m;j+=lowbit(j))</span><br><span class="line">		&#123;</span><br><span class="line">			C1[i][j]+=val;</span><br><span class="line">			C2[i][j]+=val*x;</span><br><span class="line">			C3[i][j]+=val*y;</span><br><span class="line">			C4[i][j]+=val*x*y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_add</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,ll x)</span> <span class="comment">//左上角为(x1,y1)右下角为(x2,y2)的矩阵全部加上x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	add(x1,y1,x);</span><br><span class="line">	add(x1,y2+<span class="number">1</span>,-x);</span><br><span class="line">	add(x2+<span class="number">1</span>,y1,-x);</span><br><span class="line">	add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">//查询左上角为(1,1)右下角为(x,y)的矩阵和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j))</span><br><span class="line">		&#123;</span><br><span class="line">			ret += (x+<span class="number">1</span>)*(y+<span class="number">1</span>)*C1[i][j]-(y+<span class="number">1</span>)*C2[i][j]-(x+<span class="number">1</span>)*C3[i][j]+C4[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">range_ask</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span> <span class="comment">//查询左上角为(x1,y1)右下角为(x2,y2)的矩阵和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ask(x2,y2)-ask(x1<span class="number">-1</span>,y2)-ask(x2,y1<span class="number">-1</span>)+ask(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考：<a href="https://www.cnblogs.com/dilthey/p/9366491.html#d-3" target="_blank" rel="noopener">博客</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2020/03/08/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>网络流：所有弧上流量的集合$f=\sum {f(u,v)}$,称为该容量网络的一个网络流</li>
<li>网络流图：<ul>
<li>仅有一个入度为0的顶点s，称s为源点</li>
<li>仅有一个出度为0的顶点t，称t为汇点</li>
<li>每条边的权值都为非负数，称为该边的容量，记作$c(i,j)$。</li>
</ul>
</li>
<li>弧的流量:通过容量网络G中每条弧&lt; u,v&gt;,上的实际流量(简称流量),记为$f(u,v)$;<ul>
<li>容量限制：对任意$u,v\in V，f(u,v)≤c(u,v)$。</li>
<li>反对称性：对任意$u,v\in V，f(u,v) = -f(v,u)$。从u到v的流量一定是从v到u的流量的相反值。</li>
<li>流守恒性：对任意u，若u不为S或T，一定有$\sum f(u,v)=0，(u,v)\in E$。即u到相邻节点的流量之和为0，因为流入u的流量和u点流出的流量相等，u点本身不会”制造”和”消耗”流量。</li>
</ul>
</li>
<li>可行流:在容量网络G中满足以下条件的网络流f,称为可行流.<ul>
<li>弧流量限制条件:   0&lt;=f(u,v)&lt;=c(u,v);</li>
<li>平衡条件:即流入一个点的流量要等于流出这个点的流量,(源点和汇点除外).</li>
</ul>
</li>
<li>零流：若网络流上每条弧上的流量都为0,则该网络流称为零流. </li>
<li>伪流:如果一个网络流只满足弧流量限制条件,不满足平衡条件,则这种网络流为伪流,或称为容量可行流.(预流推进算法有用)</li>
<li>最大流最小割定理: 在容量网络中,满足弧流量限制条件,且满足平衡条件并且具有最大流量的可行流,称为网络最大流,简称最大流.</li>
<li>最大流:对于网络流图G，流量最大的可行流f，称为最大流</li>
<li>弧的类型:<ul>
<li>饱和弧:即f(u,v)=c(u,v);</li>
<li>非饱和弧:即f(u,v) &lt; c(u,v)；</li>
<li>零流弧:即f(u,v)=0;</li>
<li>非零流弧:即f(u,v)&gt;0.</li>
</ul>
</li>
<li>链: 在容量网络中,称顶点序列$(u_1,u_2,u_3,..,u_n,v)$为一条链,要求相邻的两个顶点之间有一条弧,但不要求弧方向与链方向一致。</li>
<li>网络流的割：是网络中顶点的一个划分，把所有顶点划分成两个顶点集合S和T，其中源点s属于S，汇点t属于T，记作$CUT（S，T）$。</li>
<li>割的割边：如果一条弧的两个顶点一个属于顶点集S一个属于顶点集T，该弧为割CUT（S，T）的一条割边,从S指向T的割边是正向割边,从T指向S的割边是逆向割边。</li>
<li>割的容量：就是弧的容量</li>
<li>最小割：S-T割的最小值</li>
<li>最大流最小割定理：最大流等于最小割的容量</li>
<li>如果一个可行流不是最大流，那么当前网络中一定存在一条增广路 </li>
<li>增广路：设f是一个容量网络G中的一个可行流,P是从Vs到Vt 的一条链,若P满足以下条件,则称P为关于可行流f 的一条增广路.沿这增广路改进可行流的操作称为增广.:<ul>
<li>P中所有前向弧都是非饱和弧</li>
<li>P中所有后向弧都是非零弧</li>
</ul>
</li>
<li>残留容量 给定容量网络G(V,E),及可行流f,弧&lt; u,v&gt;上的残留容量记为cl(u,v)=c(u,v)-f(u,v).每条弧上的残留容量表示这条弧上可以增加的流量.因为从顶点u到顶点v的流量减少,等效与从顶点v到顶点u的流量增加,所以每条弧&lt; u,v&gt;上还有一个反方向的残留容量$cl(v,u)=-f(u,v)$.</li>
<li>残余网络 (Residual Network) 在一个网络流图上，找到一条源到汇的路径（即找到了一个流量）后，对路径上所有的边，其容量都减去此次找到的量，对路径上所有的边，都添加一条反向边，其容量也等于此次找到的流量，这样得到的新图，就称为原图的“残余网络”</li>
<li>最大流最小割的简单理解：当找到一个最大流时，必然无法在残余网络中找到一条从源点到汇点的路径，也就是此时在图中会存在至少为1个的饱和弧，此时的割为最小割，如果不是最小，那么假设还能增加，最大流也就还能增加，就前后矛盾，故最大流等于最小割</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最大网络流问题可以看成水流问题，就是有一个源头src和一个终点sink，中间有多条路径，每条路径都有一个权值，代表最多能流多少水，我们的问题是<strong>从起点到终点最多一次能流多少水量。</strong></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="反向边的引入"><a href="#反向边的引入" class="headerlink" title="反向边的引入"></a>反向边的引入</h3><p>简单说，就是增加一个反悔机制，具体的思路就是每当一条正向边u-&gt;v减少k个容量，那么反向边v-&gt;u增加k个容量，当下次dfs的时候，就可以利用反向边进行更新，如果反向边的最大流更大的话。</p>
<h3 id="E-K算法"><a href="#E-K算法" class="headerlink" title="E-K算法"></a>E-K算法</h3><p>复杂度：$O(nm^2)$<br>步骤：不断寻找增广路以扩大最大流</p>
<p>如何理解反向边?<br>可以这么理解，当以反向边为一条边能形成一条增光路的时候，那么说明这条路可通过，只需要抽象将通过这里的流分流，一部分原本路径，一部分经过这里，使其守恒</p>
<p>有哪些特点：使用了反向边和异或求反向边的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//E-K代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ipar pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>,M = <span class="number">10005</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s,t,cnt=<span class="number">1</span>,hd[M],vis[N],dis[N],pre[N],flag[N][N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,nxt;	</span><br><span class="line">	ll w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++cnt].to = v;</span><br><span class="line">	e[cnt].w = w;</span><br><span class="line">	e[cnt].nxt = hd[u];</span><br><span class="line">	hd[u] = cnt;</span><br><span class="line">	e[++cnt].to = u;</span><br><span class="line">	e[cnt].nxt = hd[v];</span><br><span class="line">	e[cnt].w = <span class="number">0</span>;</span><br><span class="line">	hd[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找增光路 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	dis[s] = inf;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x];i;i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(vis[v]||e[i].w==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">			dis[v] = MIN(e[i].w,dis[x]);</span><br><span class="line">			pre[v] = i;</span><br><span class="line">			q.push(v);</span><br><span class="line">			vis[v] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(v == t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新边权 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = t,val = dis[t];</span><br><span class="line">	<span class="keyword">while</span>(x!=s)&#123;</span><br><span class="line">		x = pre[x];</span><br><span class="line">		e[x].w -= val;</span><br><span class="line">		e[x^<span class="number">1</span>].w += val;</span><br><span class="line">		x = e[x^<span class="number">1</span>].to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u,v,w,i=m;i;--i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="keyword">if</span>(!flag[u][v])	<span class="comment">//处理重边 </span></span><br><span class="line">			add(u,v,w),flag[u][v]=cnt;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			e[flag[u][v]<span class="number">-1</span>].w+=w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(bfs())&#123;	 </span><br><span class="line">		update();	</span><br><span class="line">		ans += dis[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><p>复杂度:$O(V^2E)$</p>
<ul>
<li>bfs构建残余网，给每个节点加上一个深度</li>
<li>dfs找答案，只能往下一层找，加上回溯机制就可以ac了</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P3376" target="_blank" rel="noopener">洛谷模板题</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ipar pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">205</span>,M = <span class="number">10005</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s,t,cnt=<span class="number">1</span>,hd[M],vis[N],flag[N][N],now[M],dis[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,nxt;	</span><br><span class="line">	ll w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	e[++cnt].to = v;</span><br><span class="line">	e[cnt].w = w;</span><br><span class="line">	e[cnt].nxt = hd[u];</span><br><span class="line">	hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组建层次网络并查找增光路 ,初始化now和dis数组 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fill</span>(dis,dis+<span class="number">1</span>+n,inf);</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	q.push(s);</span><br><span class="line">	now[s] = hd[s];</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = hd[x];i;i = e[i].nxt)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">			<span class="keyword">if</span>(e[i].w &amp;&amp; dis[v]==inf)&#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">				now[v] = hd[v]; <span class="comment">//记录hd值</span></span><br><span class="line">				dis[v] = dis[x]+<span class="number">1</span>;  <span class="comment">//层次加一</span></span><br><span class="line">				<span class="keyword">if</span>(v==t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找增光路 </span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,ll in)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==t)<span class="keyword">return</span> in;</span><br><span class="line">	ll res = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = now[p];i&amp;&amp;in;i = e[i].nxt)&#123;</span><br><span class="line">		now[p] = i;</span><br><span class="line">		<span class="keyword">int</span> v = e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(e[i].w &amp;&amp; dis[v]==dis[p]+<span class="number">1</span>)&#123;	<span class="comment">//只要存在量就能通过就能dfs </span></span><br><span class="line">			k = dfs(v,MIN(in,e[i].w));</span><br><span class="line">			e[i].w -= k;</span><br><span class="line">			e[i^<span class="number">1</span>].w += k;</span><br><span class="line">			res += k;</span><br><span class="line">			in -= k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u,v,w,i=m;i;--i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		<span class="keyword">if</span>(!flag[u][v])	<span class="comment">//处理重边 </span></span><br><span class="line">			add(u,v,w),add(u,v,<span class="number">0</span>),flag[u][v]=cnt;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			e[flag[u][v]<span class="number">-1</span>].w+=w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(bfs())&#123;	 </span><br><span class="line">		ans += dfs(s,inf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/blog/_post/28077" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">参考维基百科</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路边权之积最小</title>
    <url>/2020/02/14/%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%BE%B9%E6%9D%83%E4%B9%8B%E7%A7%AF%E6%9C%80%E5%B0%8F/</url>
    <content><![CDATA[<p>当最短路不是求和的时候，而是求积，或许还会让你取模，因为数据太大，那么这个时候不能死带，而是要用log边权求和，但数据肯定有误差，所以应该记下来最短路径经过的点，然后返回即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>+<span class="number">5</span>,mod = <span class="number">9987</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ipair;</span><br><span class="line"><span class="built_in">vector</span>&lt;ipair&gt;v[maxn];</span><br><span class="line">priority_queue&lt;ipair,<span class="built_in">vector</span>&lt;ipair&gt;,greater&lt;ipair&gt; &gt;pq;</span><br><span class="line"><span class="keyword">int</span> n,m,t1,t2,t3,vis[maxn],po[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> dist[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        v[t1].push_back(make_pair(t2,t3));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)dist[i] = inf;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pq.push(make_pair(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    po[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span>,po[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = pq.top().second;</span><br><span class="line">        <span class="keyword">int</span> weight = pq.top().first;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            ipair x = v[u][i];</span><br><span class="line">            <span class="keyword">if</span>(dist[x.first] &gt;  weight +<span class="built_in">log</span>(x.second))&#123;    </span><br><span class="line">                dist[x.first] =  weight +<span class="built_in">log</span>(x.second);</span><br><span class="line">                po[x.first][<span class="number">0</span>] = u,po[x.first][<span class="number">1</span>] = x.second;</span><br><span class="line">                <span class="keyword">if</span>(!vis[x.first])&#123;</span><br><span class="line">                    pq.push(make_pair(dist[x.first],x.first));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> poi = n,ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(poi &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        ans *= po[poi][<span class="number">1</span>];</span><br><span class="line">        ans %= mod;</span><br><span class="line">        poi = po[poi][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2020/05/13/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<ul>
<li>介绍：求字符串s1,s2的公共子序列(LIS)</li>
<li>思路：<ul>
<li>dp[i][j],s1前i个的和s2的前j个的公共最长序列</li>
<li>所以遍历一次，复杂度O(nm),详情见代码</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(x, a, b) for (reg int x = a; x &lt;= b; ++x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = a.length(),lb = b.length(),ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">dp</span><span class="params">(la+<span class="number">5</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lb+<span class="number">5</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    rep(i,<span class="number">0</span>,la<span class="number">-1</span>)&#123;</span><br><span class="line">        rep(j,<span class="number">0</span>,lb<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;j)dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;j)dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i)dp[i][j]=<span class="built_in">max</span>(<span class="number">0</span>,dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j)dp[i][j]=<span class="built_in">max</span>(<span class="number">0</span>,dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; LIS(a,b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/02/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="操作系统概论"><a href="#操作系统概论" class="headerlink" title="操作系统概论"></a>操作系统概论</h2><h3 id="操作系统概念-上"><a href="#操作系统概念-上" class="headerlink" title="操作系统概念(上)"></a>操作系统概念(上)</h3><h4 id="操作系统的定位与作用"><a href="#操作系统的定位与作用" class="headerlink" title="操作系统的定位与作用"></a>操作系统的定位与作用</h4><ul>
<li>定位<ul>
<li>计算机系统由硬件和软件组成</li>
<li>OS是硬件之上的第一层软件</li>
<li>OS是其他软件和硬件的接口</li>
</ul>
</li>
<li>作用<ul>
<li>从一般用户的观点，操作系统是用户与计算机硬件系统之间的接口</li>
<li>从资源管理观点，操作系统是计算机系统资源的管理者</li>
</ul>
</li>
<li>设计目标<ul>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
</li>
</ul>
<h4 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h4><p>是计算机系统中的最基本的一种系统软件，是一些程序模块的集合。</p>
<h4 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h4><p>是计算机系统的资源管理者</p>
<ul>
<li>资源类型<ul>
<li>硬件资源 处理器、存储器、I/O设备等；</li>
<li>信息资源 程序、文件和数据等</li>
</ul>
</li>
<li>资源管理的目的<ul>
<li>实现资源共享</li>
<li>提高资源利用率</li>
</ul>
</li>
<li>资源管理者的观点<ul>
<li>记录资源的使用情况</li>
<li>合理的分配资源<ul>
<li>静态分配策略</li>
<li>动态分配策略</li>
</ul>
</li>
<li>具体完成分配</li>
<li>回收资源</li>
</ul>
</li>
<li>从资源管理和面向用户的角度看，操作系统的功能主要包括：<ul>
<li>处理器管理</li>
<li>文件管理</li>
<li>存储管理</li>
<li>网络管理</li>
<li>设备管理</li>
<li>用户接口</li>
</ul>
</li>
</ul>
<h4 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h4><ul>
<li>并发性<ul>
<li>定义：两个或两个以上的事件或活动在同一事件间隔内发生。</li>
<li>宏观上：多个程序同时在执行</li>
<li>微观上：任何时刻只有一个程序在执行</li>
</ul>
</li>
<li>共享性<ul>
<li>定义：值计算机系统中的资源可被多个并发执行的用户程序和系统程序共同使用。</li>
<li>共享形式：顺序性共享、竞争性共享。</li>
</ul>
</li>
<li>不确定性<ul>
<li>也称异步性，是指系统事件发生有随机性。</li>
</ul>
</li>
<li>虚拟性<ul>
<li>指物理上没有提供，但是逻辑上却具备的功能。</li>
<li>操作系统虚拟机</li>
<li>对系统硬件和软件资源的模拟(如虚拟处理机、虚拟内存、虚拟设备、虚拟文件系统)</li>
</ul>
</li>
</ul>
<h4 id="操作系统的性能"><a href="#操作系统的性能" class="headerlink" title="操作系统的性能"></a>操作系统的性能</h4><ul>
<li>由以下几个指标来评价操作系统的性能<ul>
<li>系统效率</li>
<li>易用性</li>
<li>系统可靠性与安全性</li>
<li>可扩充性</li>
<li>开放性</li>
<li>系统可维护性</li>
</ul>
</li>
</ul>
<h3 id="操作系统的形成与发展"><a href="#操作系统的形成与发展" class="headerlink" title="操作系统的形成与发展"></a>操作系统的形成与发展</h3><h4 id="硬件的发展"><a href="#硬件的发展" class="headerlink" title="硬件的发展"></a>硬件的发展</h4><ul>
<li>摩尔定律：每18-24个月芯片能力增长一倍</li>
<li>多类计算机纷纷产生</li>
</ul>
<h4 id="执行系统阶段"><a href="#执行系统阶段" class="headerlink" title="执行系统阶段"></a>执行系统阶段</h4><ul>
<li>两项硬件处理技术的引入</li>
<li>通道<ul>
<li>通道是一种专用处理部件，能控制一台或多台外设工作，负责外部设备和内存之间的信息传输；</li>
<li>通道被启动后能独立于CPU运行，使CPU和通道并行工作，CPU和各种外部设备也能并行运行。</li>
</ul>
</li>
<li>中断<ul>
<li>中断是指当主机接到相关信号时，停止原来的工作，转去处理相关事件；</li>
<li>处理完毕之后，主机回到原来的断点继续工作。</li>
</ul>
</li>
<li>执行系统定义：<ul>
<li>监督程序的功能被扩大了，不仅要负责调度作业自动地运行，而且还要提供输入、输出控制功能</li>
<li>系统引入通道、中断技术，输入、输出可在主机控制下完成；</li>
<li>用户不能直接启动外设，用户的输入输出请求必须通过系统去执行；</li>
<li>功能扩展的监督程序常驻内存，称为执行系统。</li>
</ul>
</li>
</ul>
<h4 id="多道程序设计阶段"><a href="#多道程序设计阶段" class="headerlink" title="多道程序设计阶段"></a>多道程序设计阶段</h4><ul>
<li>单道程序设计技术，只能执行一个任务，下个任务必须等这个任务执行完毕后执行，造成了I/O或者处理器资源浪费</li>
<li>多道程序设计技术，多道程序设计是指允许多个程序同时进入一个计算机系统的主存储器并启动进行计算的方法。<ul>
<li>从宏观上看:并行</li>
<li>从微观上看:串行</li>
<li>目的：提高效率</li>
</ul>
</li>
<li>多道程序设计技术提高资源利用率和系统吞吐率的原理<ul>
<li>让计算机同时接受两个任务，当第一道程序在等待外围设备的时候，让第二道程序运行，降低CPU空等时间，以提高处理器利用率。</li>
</ul>
</li>
<li>操作系统中引入多道程序设计的好处：<ul>
<li>提高了CPU的利用率</li>
<li>提高了内存和I/O设备的利用率</li>
<li>改进了系统的吞吐率</li>
<li>充分发挥了系统的并行性</li>
</ul>
</li>
<li>其主要缺点是：作业周转时间延长。</li>
</ul>
<h4 id="操作系统的形成"><a href="#操作系统的形成" class="headerlink" title="操作系统的形成"></a>操作系统的形成</h4><ul>
<li>分时系统：多道程序系统继承并发扬了批量处理和执行系统的特点，使得作业操作过程更加自动化，在多道程序系统出现不久就出现了分时系统。</li>
</ul>
<h3 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h3><h4 id="整体式结构"><a href="#整体式结构" class="headerlink" title="整体式结构"></a>整体式结构</h4><ul>
<li>定义：整体式结构又叫模块组合法，是基于结构化程序设计的软件结构设计方法。</li>
<li>主要设计思想：<ul>
<li>将模块作为操作系统的基本组成单位</li>
<li>按照功能需要而不是根据程序和数据的特性把整个系统分解为若干模块</li>
<li>模块可以再进一步分成子模块</li>
<li>每个模块具有一定独立功能，多个模块协作完成某个功能</li>
<li>各模块分别设计、编码、调试</li>
<li>所有模块连结成一个完整的系统</li>
</ul>
</li>
<li>主要优点：<ul>
<li>结构紧密、组合方便，对不同环境和用户的不同需求，可以组合不同模块来满足，灵活性大</li>
<li>每个功能可以用最有效的算法和调用其它模块中的过程来实现，系统效率较高</li>
<li>设计及编码可齐头并进，加快操作系统研制过程</li>
</ul>
</li>
<li>主要缺点：<ul>
<li>模块独立性差，模块之间牵连多</li>
<li>形成了复杂的调用关系，甚至有循环调用</li>
<li>系统结构不清晰，正确性、可靠性降低</li>
<li>系统功能的增、删、改十分困难</li>
</ul>
</li>
</ul>
<h4 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h4><ul>
<li>定义：<ul>
<li>操作系统划分为内核和若干模块</li>
<li>模块按功能的调用次序排列成若干层次</li>
<li>各层之间只能是单向依赖或单向调用关系</li>
</ul>
</li>
<li>层次结构类型:<ul>
<li>全序：<ul>
<li>各层之间是单向依赖的</li>
<li>层内模块之间也保持独立，没有联系</li>
</ul>
</li>
<li>半序：<ul>
<li>各层之间是单向依赖的</li>
<li>层内允许有相互调用或通信的关系</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>把整体问题局部化</li>
<li>层次结构和单向依赖性，使模块间的依赖和调用关系更为清晰规范</li>
</ul>
</li>
<li>linux操作系统的结构：硬件-&gt;内核-&gt;系统调用接口-&gt;用户进程    <ul>
<li>内核的组织方式是整体式结构<ul>
<li>Linux内核由模块组成</li>
<li>每个模块可以单独编译</li>
<li>模块用链接程序连在一起成为目标程序</li>
</ul>
</li>
<li>内核是基于过程的开放结构<ul>
<li>有利于不同的人参与不同过程的开发</li>
<li>允许任何人对其进行修改和完善</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h4><ul>
<li>定义：<ul>
<li>虚拟化是计算机资源的抽象方法</li>
<li>虚拟机是通过软件模拟的、运行在隔离环境中的计算<br>机系统</li>
<li>实体计算机中能够完成的工作在虚拟机中都能够实现</li>
</ul>
</li>
<li>方法：<ul>
<li>在裸机上层层扩展软件</li>
<li>可采用层次化结构的设计方法来实现</li>
<li>经过虚拟化后的逻辑资源对用户隐藏了不必要的细节</li>
</ul>
</li>
</ul>
<h4 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户/服务器结构"></a>客户/服务器结构</h4><ul>
<li>基本思想：<ul>
<li>运行在用户态并以客户/服务器方式<br>活动的进程</li>
<li>运行在核心态的内核</li>
</ul>
</li>
<li>除内核外，操作系统的其它部分被分成若干相对独立的进程，每一个进程实现一类服务，称服务器进程。用户进程也在该层并以客户/服务器方式活动。</li>
<li>客户进程发出消息，内核将消息传送给服务器进程，服务器进程执行客户提出的服务请求，在满足客户的要求后再通过内核发送消息把结果返回给用户。</li>
</ul>
<h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><ul>
<li>定义：<ul>
<li>把操作系统中的内存管理、设备管理、文件系<br>统等功能模块尽可能地从内核中分离出来</li>
<li>在内核只保留少量最基本的功能，使内核变得<br>简洁可靠</li>
</ul>
</li>
<li>优点：<ul>
<li>充分的模块化，可独立更换任一模块而不会影响其它模块，从而方便第三方设计、开发各个模块未被使用的模块功能不必运行，大幅度减少系统的内存需求</li>
<li>增强可移植性，移植时主要对微内核部分进行修改即可，减轻移植工作量。</li>
</ul>
</li>
</ul>
<h2 id="操作系统概念-下"><a href="#操作系统概念-下" class="headerlink" title="操作系统概念(下)"></a>操作系统概念(下)</h2><h3 id="进程及其实现"><a href="#进程及其实现" class="headerlink" title="进程及其实现"></a>进程及其实现</h3><h4 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h4><ul>
<li>进程是为了描述程序在并发执行时对系统资源的共享，所需的一个描述程序执行时动态特征的概念。</li>
<li>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配、调度和保护的独立单位。</li>
</ul>
<h4 id="进程的类型与特性"><a href="#进程的类型与特性" class="headerlink" title="进程的类型与特性"></a>进程的类型与特性</h4><ul>
<li>进程分类：系统进程、用户进程</li>
<li>进程的属性：结构性、共享性、动态性、独立性、制约性、并发性</li>
<li>程序与进程之间的区别：<ul>
<li>进程能真实地描述并发，而程序不能</li>
<li>进程是由程序和数据和控制块组成</li>
<li>程序是静态的，进程是动态的</li>
<li>进程有生命周期，程序是相对长久的</li>
<li>一个程序可对应多个进程，反之亦然</li>
<li>进程具有创建其它进程的功能，程序没有</li>
</ul>
</li>
</ul>
<h4 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h4><ul>
<li>进程的三种状态：<ul>
<li>运行态（Running)：进程占有CPU，并在CPU上运行</li>
<li>就绪态（Ready）：<ul>
<li>一个进程已经具备运行条件，但没有分配CPU，暂时不能运行</li>
<li>当调度给该进程CPU时，立即可以运行</li>
</ul>
</li>
<li>等待态（Blocked）：<ul>
<li>阻塞态、封锁态、睡眠态</li>
<li>进程因等待某事件的发生而暂时不能运行的状态</li>
<li>即使CPU空闲，该进程也不可运行</li>
</ul>
</li>
</ul>
</li>
<li>完整的七状态进程模型<br>  <img src="进程状态.png" alt=""></li>
<li>为什么要有“挂起”状态?<ul>
<li>进程的不断创建，系统资源已不能满足进程运行的要求</li>
<li>某些进程挂起，对换到磁盘镜像区中，暂时不参与进程调度，平滑系统操作的负荷</li>
</ul>
</li>
</ul>
<h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><ul>
<li>定义：进程控制块（Process Control Block，PCB）是系统为了管理进程设置的专门数据结构，用来记录进程的外部特征，描述进程的变化过程</li>
<li>系统利用PCB来控制和管理进程，PCB是系统感知进程存在的唯一标志</li>
<li>构成:<ul>
<li>进程描述信息<ul>
<li>进程标识符(process ID)，唯一，通常是一个整数</li>
<li>进程名，通常基于可执行文件名（不唯一）</li>
<li>用户标识符(user ID)</li>
<li>进程组关系</li>
</ul>
</li>
<li>进程控制信息<ul>
<li>当前状态</li>
<li>优先级</li>
<li>代码执行入口地址</li>
<li>程序的外存地址</li>
<li>运行统计信息</li>
<li>进程间同步和通信</li>
<li>阻塞原因</li>
<li>进程的队列指针</li>
<li>进程的消息队列指针</li>
</ul>
</li>
<li>所拥有的资源和使用情况<ul>
<li>虚拟地址空间的现状</li>
<li>打开文件列表</li>
</ul>
</li>
<li>CPU现场保护信息<ul>
<li>寄存器值（通用、程序计数器PC、状态PSW，地址包括栈指针）</li>
<li>指向赋予该进程的段/页表的指针</li>
</ul>
</li>
</ul>
</li>
<li>组织<ul>
<li>系统把PCB组织在一起，放在内存，构成PCB表</li>
<li>PCB表大小决定了系统中最多可同时存在的进程个数，称为系统的并发度</li>
</ul>
</li>
</ul>
<h4 id="进程要素"><a href="#进程要素" class="headerlink" title="进程要素"></a>进程要素</h4><ul>
<li>组成<ul>
<li>进程控制块<br>  <img src="进程控制块.png" alt=""></li>
<li>进程程序</li>
<li>进程数据</li>
<li>栈</li>
</ul>
</li>
<li>进程上下文<ul>
<li>进程本身＋运行环境，由进程的用户地址空间内容、硬件寄存器内容及与该进程相关的核心数据结构组成</li>
<li>寄存器级上下文：PSW寄存器、处理器状态寄存器、栈指针、通用寄存器的值</li>
<li>系统级上下文：<ul>
<li>静态部分：PCB和资源表格</li>
<li>动态部分：核心栈（核心过程的栈结构，不同进程在调用相同核心过程时有不同核心栈）</li>
</ul>
</li>
<li>用户级上下文：进程的用户地址空间，包括用户正文段、用户数据段和用户栈</li>
</ul>
</li>
<li>进程上下文切换<ul>
<li>保存被中断进程的处理器现场信息</li>
<li>修改被中断进程的进程控制块的有关信息，如进程状态等</li>
<li>把被中断进程的进程控制块加入有关队列</li>
<li>选择下一个占有处理器运行的进程</li>
<li>修改被选中进程的进程控制块的有关信息</li>
<li>根据被选中进程设置操作系统用到的地址转换和存储保护信息</li>
<li>根据被选中进程恢复处理器现场</li>
</ul>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="进程控制原语"><a href="#进程控制原语" class="headerlink" title="进程控制原语"></a>进程控制原语</h4><ul>
<li>含义：系统使用一些具有特定功能的程序段来创建、撤消进程以及完成进程在各状态间转换</li>
<li>目标：实现多进程高效率并发执行、协调和共享资源的目的</li>
<li>类型：创建进程、阻塞进程、唤醒进程、挂起进程、激活进程和撤销进程等</li>
<li>特点：<ul>
<li>进程控制和管理功能是由原语来实现</li>
<li>原语是在管态下执行、完成系统特定功能的程序</li>
<li>原语执行过程中不允许被中断</li>
</ul>
</li>
</ul>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><ul>
<li>创建原因<ul>
<li>用户提交作业</li>
<li>用户在终端上登录</li>
<li>系统创建服务进程</li>
<li>进程孵化子进程</li>
</ul>
</li>
<li>创建过程<ul>
<li>系统从PCB池中取一个空白PCB</li>
<li>为新进程的映像分配地址空间，传递环境变量，</li>
<li>构造共享地址空间</li>
<li>为新进程分配内存等各种资源</li>
<li>查找辅存，找到进程正文段并装到正文区</li>
<li>初始化进程控制块，分配进程标识符，初始化PSW</li>
<li>将进程加入就绪进程队列，投入运行</li>
<li>通知操作系统的记账程序、监控程序等</li>
</ul>
</li>
</ul>
<h4 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h4><ul>
<li>进程阻塞<ul>
<li>阻塞原语在进程期待某事件发生，但没有发生时，或所需资源尚不具备时，被该进程调用来阻塞自己</li>
<li>阻塞进程时，先中断处理器，保存该进程的CPU现场信息到PSW</li>
<li>将被阻塞进程置“阻塞”状态后，插入等待队列中进程调度程序选择新的就绪进程投入运行</li>
</ul>
</li>
<li>进程唤醒<ul>
<li>系统唤醒进程：系统进程统一控制事件的发生并将事件发生的消息通知等待进程，使得该进程进入就绪队列</li>
<li>事件发生唤醒进程：事件发生进程和被唤醒进程之间是合作关系，唤醒原语既可被系统进程调用，也可被事件发生进程调用</li>
</ul>
</li>
</ul>
<h4 id="进程的撤消"><a href="#进程的撤消" class="headerlink" title="进程的撤消"></a>进程的撤消</h4><ul>
<li>撤消缘由<ul>
<li>进程已完成所要求的功能而正常终止</li>
<li>由于某种错误导致非正常终止</li>
<li>祖先进程要求撤消某个子孙进程</li>
</ul>
</li>
<li>撤销步骤<ul>
<li>根据进程标识号，从相应队列中找到它的PCB</li>
<li>将该进程拥有的资源归还给父进程或操作系统</li>
<li>若该进程拥有子进程，先撤销子孙进程，以防脱离控制撤销进程出队，将它的PCB归还到PCB池</li>
</ul>
</li>
</ul>
<h4 id="进程的挂起和激活"><a href="#进程的挂起和激活" class="headerlink" title="进程的挂起和激活"></a>进程的挂起和激活</h4><ul>
<li>挂起过程<ul>
<li>检查要被挂起进程的状态，若处于就绪态就修改为挂起就绪态，若处于阻塞态，则修改为挂起阻塞态</li>
<li>被挂起进程PCB的非常驻部分交换到磁盘对换区激活过程</li>
</ul>
</li>
<li>激活过程<ul>
<li>将进程PCB非常驻部分调进内存，修改状态，挂起等待态改为等待态，挂起就绪态改为就绪态挂起</li>
<li>原语既可由进程自己也可由其他进程调用，但激活原语却只能由其他进程调用</li>
</ul>
</li>
</ul>
<h3 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h3><h4 id="处理器调度的层次"><a href="#处理器调度的层次" class="headerlink" title="处理器调度的层次"></a>处理器调度的层次</h4><ul>
<li>调度层次<br><img src="调度层次.png" alt=""></li>
<li>作业与进程<ul>
<li>作业是用户向计算机提交的任务实体，而进程则是完成任务的执行实体，是系统分配资源的基本单位</li>
<li>一个作业可由多个进程组成，且必须至少由一个进程组成，反过来不成立</li>
<li>Linux等分时系统中，并不强调作业概念</li>
</ul>
</li>
</ul>
<h4 id="处理器调度的算法"><a href="#处理器调度的算法" class="headerlink" title="处理器调度的算法"></a>处理器调度的算法</h4><ul>
<li>调度原则<ul>
<li>合理性：既要保证系统实现特殊功能要求，同时要对各个任务合理地分配到处理器份额</li>
<li>有效性：处理器、内存和I/O设备得到合理有效的分配， 使系统资源得到充分的利用</li>
</ul>
</li>
<li>性能衡量主要指标<ul>
<li>作业平均周转时间<br><img src="作业平均周转时间.png" alt=""></li>
<li>平均带权周转时间<br><img src="平均带权周转时间.png" alt=""></li>
</ul>
</li>
<li>典型算法<ul>
<li>先来先服务算法FCFS</li>
<li>最短作业优先算法SJF</li>
<li>最短剩余时间优先算法SRTF</li>
<li>最高响应比优先算法HRN</li>
</ul>
</li>
</ul>
<blockquote>
<p>   响应比 = 作业周转时间 / 作业处理时间=（作业处理时间+作业等待时间）/ 作业处理时间= 1 +（作业等待时间 / 作业处理时间）</p>
</blockquote>
<h2 id="并发进程"><a href="#并发进程" class="headerlink" title="并发进程"></a>并发进程</h2><h3 id="进程联系"><a href="#进程联系" class="headerlink" title="进程联系"></a>进程联系</h3><h4 id="顺序程序与顺序环境"><a href="#顺序程序与顺序环境" class="headerlink" title="顺序程序与顺序环境"></a>顺序程序与顺序环境</h4><ul>
<li>顺序环境<ul>
<li>程序的指令或语句序列是顺序的</li>
<li>在计算机系统中只有一个程序在运行</li>
<li>一个程序独占系统中所有资源</li>
<li>一个程序执行不受外界影响</li>
</ul>
</li>
<li>顺序特征<ul>
<li>顺序性执行</li>
<li>封闭独占资源</li>
<li>确定可再现性</li>
</ul>
</li>
</ul>
<h4 id="并发环境与并发进程"><a href="#并发环境与并发进程" class="headerlink" title="并发环境与并发进程"></a>并发环境与并发进程</h4><ul>
<li>并发环境 <ul>
<li>在一定时间内物理机器上有两个或两个以上的程序</li>
<li>程序处于开始运行但尚未结束的状态</li>
<li>程序执行次序不是事先确定的</li>
</ul>
</li>
<li>并发特征<ul>
<li>程序结果的不可再现性</li>
<li>程序的执行呈现间断性</li>
<li>系统中各类资源共享</li>
<li>独立性和制约性</li>
<li>程序和计算不再对应</li>
</ul>
</li>
</ul>
<h4 id="与时间有关的不确定"><a href="#与时间有关的不确定" class="headerlink" title="与时间有关的不确定"></a>与时间有关的不确定</h4><p>由于共享变量，那么同一变量不同时间可能不同的，所以具有不确定性。</p>
<h4 id="相交进程与无关进程"><a href="#相交进程与无关进程" class="headerlink" title="相交进程与无关进程"></a>相交进程与无关进程</h4><ul>
<li>间接式与直接式制约<ul>
<li>直接作用<ul>
<li>两个具有合作关系的进程</li>
</ul>
</li>
<li>间接作用<ul>
<li>两个没有合作关系的进程竞争资源</li>
</ul>
</li>
</ul>
</li>
<li>相交与无关进程<ul>
<li>相交进程<ul>
<li>并发进程在逻辑上有某种联系</li>
</ul>
</li>
<li>无关进程 <ul>
<li>逻辑上无任何联系的并发进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h4><ul>
<li>进程的同步（直接作用）<br>  —根据一定的时序关系合作完成一项任务<ul>
<li>并发进程因直接制约而互相等待，彼此相互发送消息进行合作，使得各进程按一定的速度执行</li>
<li>进程间的相互联系是有意识的安排的，直接作用只发生在相交进程间</li>
</ul>
</li>
<li>进程互斥（间接作用）<br>  —各进程竞争使用临界资源<ul>
<li>临界资源：一次只允许一个进程使用的系统资源</li>
<li>进程间通过中介发生联系，是无意识安排的</li>
<li>可发生在相交进程间，也可发生在无关进程间</li>
</ul>
</li>
</ul>
<h3 id="信号量与P、V操作"><a href="#信号量与P、V操作" class="headerlink" title="信号量与P、V操作"></a>信号量与P、V操作</h3><blockquote>
<p>那么如何解决互斥进程运行时临界资源的分配问题呢？</p>
</blockquote>
<p>可以使用信号量管理和P、V操作</p>
<ul>
<li>信号量<ul>
<li>一个结构体，有一个值和一个队列指针</li>
<li>值是临界资源的容量，队列指针中存放等待执行的进程</li>
</ul>
</li>
<li>P、V操作<ul>
<li>是原语，无法被打断</li>
<li>P是操作资源，V是返还资源<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="built_in">queue</span>*q;</span><br><span class="line">&#125;</span><br><span class="line">P(s,task)&#123;</span><br><span class="line">	s.value--;</span><br><span class="line">	<span class="keyword">if</span>(s.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//阻塞，加入队列</span></span><br><span class="line">		s.<span class="built_in">queue</span>.push(task);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//执行任务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">V(s)&#123;</span><br><span class="line">	s.value++;</span><br><span class="line">	<span class="keyword">if</span>(s.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//执行队列中的一个任务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>信号量的作用<ul>
<li>可以解决所有的同步互斥问题</li>
<li>单类机票问题：设置一个信号量即可</li>
<li>多类机票问题：设置多个信号量即可</li>
<li>生产者，消费者问题：设置两个信号量相互作用即可。</li>
</ul>
</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="进程通信概念与类型"><a href="#进程通信概念与类型" class="headerlink" title="进程通信概念与类型"></a>进程通信概念与类型</h4><ul>
<li>概念：进程在系统里同时运行，并相互传递，交换消息</li>
<li>作用：数据传输、共享数据、通知事件、资源共享、进程控制</li>
<li>类型：低级通信、高级通信</li>
<li>通信方式<ul>
<li>数据格式：字节格式、报文格式</li>
</ul>
</li>
</ul>
<h4 id="低级通信与信号通信"><a href="#低级通信与信号通信" class="headerlink" title="低级通信与信号通信"></a>低级通信与信号通信</h4><h4 id="高级通信与共享存储"><a href="#高级通信与共享存储" class="headerlink" title="高级通信与共享存储"></a>高级通信与共享存储</h4><h4 id="高级通信与消息通信"><a href="#高级通信与消息通信" class="headerlink" title="高级通信与消息通信"></a>高级通信与消息通信</h4><h4 id="高级通信与管道通信"><a href="#高级通信与管道通信" class="headerlink" title="高级通信与管道通信"></a>高级通信与管道通信</h4>]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>树形dp模版</title>
    <url>/2020/04/26/%E6%A0%91%E5%BD%A2dp%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<p>树形dp显而易见，就是在一棵数上进行dp，说到树，必然有dfs或bfs进行遍历<br>此处我们使用f[i][j]说明第i个节点的状态，使用dfs遍历<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">6e3</span>+<span class="number">5</span>,inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[maxn][<span class="number">2</span>],ans = <span class="number">0</span>,root,r[maxn],fa[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;rel[maxn];</span><br><span class="line"><span class="comment">//dfs没问题的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[p][<span class="number">0</span>]||f[p][<span class="number">1</span>])<span class="keyword">return</span>;</span><br><span class="line">    f[p][<span class="number">1</span>] += r[p];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rel[p].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        dfs(rel[p][i]);</span><br><span class="line">        f[p][<span class="number">0</span>] += <span class="built_in">max</span>(f[rel[p][i]][<span class="number">1</span>],f[rel[p][i]][<span class="number">0</span>]);</span><br><span class="line">        f[p][<span class="number">1</span>] += f[rel[p][i]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> l,k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; k;</span><br><span class="line">        rel[k].push_back(l);</span><br><span class="line">        fa[l] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,<span class="built_in">max</span>(f[i][<span class="number">0</span>],f[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>求素数</title>
    <url>/2020/02/12/%E6%B1%82%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<p>介绍：要求1-n中有多少个数是素数</p>
<h2 id="初级方法"><a href="#初级方法" class="headerlink" title="初级方法"></a>初级方法</h2><p>对于n,从i = 2到i = sqrt(n)，一个个的遍历，耗时很大，会超时<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= t;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="埃拉托斯特尼筛选法"><a href="#埃拉托斯特尼筛选法" class="headerlink" title="埃拉托斯特尼筛选法"></a>埃拉托斯特尼筛选法</h2><p>复杂度位O(nloglogn)<br>设定一个数组f[n],f[i] = 1表示i为素数，vis[n],vis[i] = 1表示是否访问过<br>从i = 2到n遍历，未访问的设为1，然后j = i+i ，开始遍历每个i的倍数，直到n</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			f[i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+i;j &lt;= n;j += i)&#123;</span><br><span class="line">				f[j] = <span class="number">0</span>;</span><br><span class="line">				vis[j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛选法"><a href="#欧拉筛选法" class="headerlink" title="欧拉筛选法"></a>欧拉筛选法</h2><p>对埃拉托斯特尼筛选法进行了改进，因为埃拉托斯特尼筛选法会对一些重复项进行重复判断，例如2的倍数与3的倍数重合了，那么每次筛选的时候就只使用已经求过的素数进行筛选,即用一个数组vector<int>v记录已经求得的质因数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	rep(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])stac[++top]=i;</span><br><span class="line">		rep(j,<span class="number">1</span>,top)&#123;</span><br><span class="line">			<span class="keyword">if</span>(stac[j]*i &gt; N)<span class="keyword">break</span>;</span><br><span class="line">			vis[stac[j]*i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%stac[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Sundaram筛选法、Atkin筛选法</p>
<h2 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h2><p>耗时：Sundaram &lt; 欧拉 = Atkin &lt; 埃拉托斯特尼。</p>
<p>空间占用：Sundaram &lt; 埃拉托斯特尼 = Atkin &lt; 欧拉。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>最小表示法</title>
    <url>/2020/08/01/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>最小表示法其实就是找到位置i，从这个位置输出S，使得到的同构串字典序最小。</li>
<li>思路：<br>  设S的长度为len</li>
</ul>
<ol>
<li>利用两个指针i，j。初始化时i指向s[0]，j指向s[1]。<br>我们规定i和j在任意时刻都不能相等。</li>
<li>匹配长度k=0开始，检验s[i+k]和s[j+k]是否相等，相等k++，一直下去，直到找到第一个不相同的字符</li>
<li>如果长度不相等，那么修改i+k与j+k中较大的数组id，假设a[i+k]较大，那么令i=i+k+1，因为从i到i+k，j应该是更正确的选择</li>
</ol>
<p><a href="https://www.luogu.com.cn/problem/P1368" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp(a,b) make_pair(a,b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ipar pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b) for(int i = a;i &lt;= b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> drp(i,a,b) for(int i = a;i &gt;= b;--i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>,flag = <span class="number">1</span>;<span class="keyword">char</span> c = gc();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;flag=c==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>;c=gc();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))&#123;res=res*<span class="number">10</span>+(c^<span class="number">48</span>);c=gc();&#125;</span><br><span class="line">	<span class="keyword">return</span> res*flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span>+<span class="number">5</span>,inf = <span class="number">0x3f3f3f3f</span>,md = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ms</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= n &amp;&amp; j &lt;= n &amp;&amp; k &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[(i+k)%n]==a[(j+k)%n])++k;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[(i+k)%n]&gt;a[(j+k)%n])i = i + k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> j = j + k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i==j)++i;</span><br><span class="line">			k=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	rep(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		a[i]=rd();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> res = ms();</span><br><span class="line">	rep(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,a[(i+res)%n],i==n<span class="number">-1</span>?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫精析</title>
    <url>/2020/06/02/%E7%88%AC%E8%99%AB%E7%B2%BE%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爬虫是python一个最简单之一的应用了，就是模拟浏览器对资源进行筛选，下载，用到的东西不多，大多的调用一些库进行调用就可以达到目的，但是学习的过程中将对计算机网络，python基础，数据库，数据结构与算法等知识进行链接，故，作为入门的项目再好不过了</p>
<h2 id="初级爬虫"><a href="#初级爬虫" class="headerlink" title="初级爬虫"></a>初级爬虫</h2><h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p><a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="noopener">Doc</a></p>
<p>主要下面四种module</p>
<ul>
<li>urllib.request for opening and reading URLs</li>
<li>urllib.error containing the exceptions raised by urllib.request</li>
<li>urllib.parse for parsing URLs</li>
<li>urllib.robotparser for parsing robots.txt files*</li>
</ul>
<p>功能：<strong>发送请求，处理异常，解析链接</strong>，分析robots协议(用得少)</p>
<ul>
<li>request<ul>
<li>Request()：封装发送头，发送方法等等 <strong>class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)</strong></li>
<li>urlopen()：直接传入Request()函数返回的Request对象，此函数返回的对象为<strong>http.client.HTTPResponse</strong>，需要调用 <strong>read()</strong> 返回 <strong>bytes对象</strong> ，如果使用 <strong>chardet.detect()</strong> 函数发现不是utf-8编码，还可用 <strong>decode()</strong> 转换编码</li>
</ul>
</li>
<li>error<ul>
<li>当url返回出错的时候，可以打印错误</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="string">'https://cuiqingcai.com/index.htm'</span>)  </span><br><span class="line"><span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:  </span><br><span class="line">    print(e.reason, e.code, e.headers, sep=<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>parse</li>
</ul>
<h3 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h3>]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
  </entry>
  <entry>
    <title>欧拉函数与欧拉定理</title>
    <url>/2020/05/09/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><ul>
<li>定义：φ(n)即欧拉函数，为1-n中与n互质的数的个数</li>
<li>互质：a与b互质即a与b只有1一个公因数，特殊地，1与1互质，其他任何数与它本身不互质</li>
<li>性质</li>
</ul>
<p>n为素数时，显然，</p>
<script type="math/tex; mode=display">
      φ(n)=n-1</script><p>前面n-1个数都与他互质</p>
<p>n为互质数之积时，即$n=ab$,那么</p>
<script type="math/tex; mode=display">
      φ(n)=φ(a)*φ(b)</script><p>n为素数的幂时，即</p>
<script type="math/tex; mode=display">
      n=p^k</script><p>(p为素数)，有且仅有以下数与他互为合数：</p>
<script type="math/tex; mode=display">
p,2p,3p,,,m p，其中m=p^{k-1}</script><script type="math/tex; mode=display">
φ(n) = n-m = p^k  -  p^{k-1} = p^k(1-1/p) = n(1-1/p)</script><p>n为一个任意数时，可以分解为$n=p_1^{k_1} <em> p_2^{k_2} </em>,,,p_m^{k_m}$，显然，其中任意两项都是互质的，因为两项都是质数的积，可以用反证法来证明，那么根据第二项性质得到</p>
<script type="math/tex; mode=display">
\phi(n)=φ(p_1^k1)φ(p_2^k2),,,φ(p_m^km)\\
\phi(p_1^k1)=p_1^k1*(1-1/p_1)\\
\phi(n)=n(1-1/p_1)(1-1/p_2),,,(1-1/p_m)</script><p>根据以上性质，得到以下程序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个n的欧拉函数求解,复杂度O(n^0.5)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(x);++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">			ans = ans/i*(i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">while</span>(x%i==<span class="number">0</span>)x/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;<span class="number">1</span>)ans = ans/x*(x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>欧拉函数的线性筛法,复杂度O(n)<br>线性筛的原则是每一个合数都是被最小的质因子筛掉<br>比如p是N的最小质因子<br>那么</p>
<script type="math/tex; mode=display">
n=\frac{N}{p}</script><p>,线性筛的过程中N通过n*p筛掉<br>当</p>
<script type="math/tex; mode=display">
n \% p_1 = 0</script><p>时，那么n包含了N的所有质因子</p>
<script type="math/tex; mode=display">
\phi(N)=N*\Pi_{i=1}^{s}(\frac{p_i-1}{p_i})=p*n*\Pi_{i=1}^{s}(\frac{p_i-1}{p_i})
=p*\phi(n)</script><script type="math/tex; mode=display">
n mod p_1 != 0时，那么\phi(N)=(p-1)*\phi(n)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* phi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,p[N],flag[N]=&#123;<span class="number">0</span>&#125;;<span class="comment">//p为素数的值，flag标记是否为合数，初始都为合数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">            p[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cnt;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*p[j] &gt; n)<span class="keyword">break</span>;</span><br><span class="line">            flag[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*p[j]] = p[j]*phi[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                phi[i*p[j]] = (p[j]<span class="number">-1</span>)*phi[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉定理的证明"><a href="#欧拉定理的证明" class="headerlink" title="欧拉定理的证明"></a>欧拉定理的证明</h2><p>若gcd(a,m)=1,则</p>
<script type="math/tex; mode=display">
a^{φ(m)}=1(mod m)</script><p>证明：</p>
<script type="math/tex; mode=display">
令p_i=ax_i\\
\because gcd(a,n)\equiv1,gcd(x_i,n)\equiv1\\
\therefore gcd(p_i,n)\equiv1\\
\therefore \sum_{i=1}^{\phi(n)}p_i\equiv\sum_{i=1}^{\phi(n)}x\equiv1\\
\because \sum_{i=1}^{\phi(n)}p_i=a^{\phi(n)}*\sum_{i=1}^{\phi(n)}x\\
\therefore 移项得a^{\phi(n)}\equiv1</script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2020/02/22/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="线性方程组的求解"><a href="#线性方程组的求解" class="headerlink" title="线性方程组的求解"></a>线性方程组的求解</h2><p>描述：给出ax=b,其中a,x,b都为矩阵，求x</p>
<p>模板链接：<a href="https://www.luogu.com.cn/problem/P3389" target="_blank" rel="noopener">传送门</a></p>
<p>思路：运用高斯-约旦消元法<br>    1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。<br>    2.将这个方程主元的系数化为1。<br>    3.通过加减消元，消掉其它方程中的这个未知数。<br>    4.重复以上步骤，直到把所有式子变成形如: a1+b0+c*0……=d</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D double</span></span><br><span class="line">D a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="comment">//枚举列（项） </span></span><br><span class="line">	&#123;</span><br><span class="line">		re <span class="keyword">int</span> <span class="built_in">max</span> = i;</span><br><span class="line">		<span class="keyword">for</span> (re <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)<span class="comment">//选出该列最大系数 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">fabs</span>(a[j][i]) &gt; <span class="built_in">fabs</span>(a[<span class="built_in">max</span>][i]))</span><br><span class="line">				<span class="comment">//fabs是取浮点数的绝对值的函数</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">max</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)<span class="comment">//交换</span></span><br><span class="line">		&#123;</span><br><span class="line">			swap(a[i][j], a[<span class="built_in">max</span>][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!a[i][i])<span class="comment">//最大值等于0则说明该列都为0，肯定无解 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (re <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)<span class="comment">//每一项都减去一个数（就是小学加减消元）</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (j != i)</span><br><span class="line">			&#123;</span><br><span class="line">				re D temp = a[j][i] / a[i][i];</span><br><span class="line">				<span class="keyword">for</span> (re <span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k)</span><br><span class="line">				&#123;</span><br><span class="line">					a[j][k] -= a[i][k] * temp;</span><br><span class="line">					<span class="comment">//a[j][k]-=a[j][i]*a[i][k]/a[i][i];</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上述操作结束后，矩阵会变成这样</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	k1*a=e1</span></span><br><span class="line"><span class="comment">	k2*b=e2</span></span><br><span class="line"><span class="comment">	k3*c=e3</span></span><br><span class="line"><span class="comment">	k4*d=e4</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//所以输出的结果要记得除以该项系数，消去常数</span></span><br><span class="line">	<span class="keyword">for</span> (re <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, a[i][n + <span class="number">1</span>] / a[i][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算</title>
    <url>/2020/02/22/%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>ax=b(mod m)，也相当于(ax)%m=b<br>同样在模数m的运算下，也满足ay=1(mod m),y记作a的逆元a^-1<br>如果求得了y,通过x = y*xa-&gt;x=by 可以求出x</p>
<ul>
<li>求y<ul>
<li>ay=1(mod m) == ay=1+mk == ay-mk=1</li>
<li>使用extgcd求解出一组解</li>
</ul>
</li>
</ul>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>对于素数p，对任意整数都有<br>x^p=x(mod p),其中，如果x无法被p整除(即x%p!=0)<br>得到pow(x,p-1)=1(mod p)<br>两边同时*pow(a,-1)<br>得到pow(a,-1)=pow(a,m-2) (mod m)<br>然后使用快速幂算法得到a的逆</p>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉函数φ(n) ：表示小于等于 n 的正整数中与 n 互质的数的个数。<br>性质：</p>
<pre><code>* 积性函数，φ(mn)=φ(n)φ(m)
* 推论：φ(2n)=φ(n)
* 求解：φ(n)=n*(1-pi)(i=1-&gt;k,pi为n的因数)
</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> re = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			re=(re-re/i);</span><br><span class="line">			<span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">				n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)re = re-re/n;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉定理：a 与 m 互质时，pow(a,φ(m))=1(mod m)<br>扩展欧拉定理：无需a,m互质，b &gt;= φ(m)时，pow(a,b)=pow(a,b % φ(m)+φ(m)) % m</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2020/02/19/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>最长上升子序列就是指在一个序列当中，某个子序列满足任意i &lt; j,a[i] &lt; a[j]</p>
<h2 id="n2枚举算法"><a href="#n2枚举算法" class="headerlink" title="n2枚举算法"></a>n2枚举算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">				dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nlogn算法"><a href="#nlogn算法" class="headerlink" title="nlogn算法"></a>nlogn算法</h2><p>可以看出，每次n2算法都是找i前面的dp数最大的且比a[i]小的值，那么我们制造一个数组d[maxn]进行存储</p>
<ul>
<li>如果a[i]比d[len]大，那么添加到d数组后面，++len</li>
<li>如果a[i]比d[len]小，那么在d数组中找到第一个比a[i]大的值，进行替换即可<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d[maxn],len = <span class="number">1</span>;</span><br><span class="line">	d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; d[len])d[++len]=a[i];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> p = lower_bound(d+<span class="number">1</span>,d+<span class="number">1</span>+len,a[i])-d;</span><br><span class="line">			d[p] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2020/07/31/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<ul>
<li>描述：给定n*n的矩阵A，求A的k次方</li>
<li>算法：跟快速幂无异，只需要定义一个结构体和结构体运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() getchar()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = a; i &lt;= b; ++i)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll a=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> p=gc();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(p))&#123;f|=p==<span class="string">'-'</span>;p=gc();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(p))&#123;a=(a&lt;&lt;<span class="number">3</span>)+(a&lt;&lt;<span class="number">1</span>)+(p^<span class="number">48</span>);p=gc();&#125;</span><br><span class="line">	<span class="keyword">return</span> f?-a:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	ll a[maxn][maxn];     <span class="comment">//一定要用long long存矩阵，否则在过程中会爆掉</span></span><br><span class="line">	Matrix()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;     <span class="comment">//建造单位矩阵</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;x,<span class="keyword">const</span> Matrix &amp;y)&#123;     <span class="comment">//重载运算符</span></span><br><span class="line">	Matrix z;</span><br><span class="line">	rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">		rep(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">			rep(k,<span class="number">1</span>,n)&#123;</span><br><span class="line">				z.a[i][j] = (z.a[i][j]+x.a[i][k]*y.a[k][j]%mo)%mo;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">			a.a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	Matrix ans;ans.build();</span><br><span class="line">	<span class="keyword">do</span>&#123;     <span class="comment">//递推快速幂，与普通的递推快速幂无异，但*不能缩写为*=</span></span><br><span class="line">		<span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*a;</span><br><span class="line">		a=a*a;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans.a[i][j],j==n?<span class="string">'\n'</span>:<span class="string">' '</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>状压dp</title>
    <url>/2020/05/28/%E7%8A%B6%E5%8E%8Bdp/</url>
    <content><![CDATA[<p>概念：将一个集合的选取压缩成一个整数，作为数组的一个下标进行dp，但是，状压dp的核心还是dp，状态压缩只是手段。</p>
<p><a href="https://www.luogu.com.cn/problem/P3052" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,w;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">18</span>];<span class="comment">//f[i]状态为i的最小次数</span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">1</span>&lt;&lt;<span class="number">18</span>];<span class="comment">//g[i]状态为i时,最后一个电梯的剩余体积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;w);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	g[<span class="number">0</span>]=w;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">	<span class="comment">//枚举状态 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		<span class="comment">//枚举每一头奶牛 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i &amp; (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))) <span class="keyword">continue</span>;<span class="comment">//如果这头奶牛已经在电梯里了</span></span><br><span class="line">			<span class="keyword">if</span>(g[i]&gt;=a[j])</span><br><span class="line">			<span class="comment">//如果这个电梯坐得下</span></span><br><span class="line">			&#123;</span><br><span class="line">				f[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]=f[i];</span><br><span class="line">				<span class="comment">//让奶牛坐电梯</span></span><br><span class="line">				<span class="comment">//合并答案 </span></span><br><span class="line">				g[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]=<span class="built_in">max</span>(g[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))],g[i]-a[j]);</span><br><span class="line">				<span class="comment">//更新剩余体积 </span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				f[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]=f[i]+<span class="number">1</span>;<span class="comment">//电梯次数+1 </span></span><br><span class="line">				g[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]=<span class="built_in">max</span>(g[i | (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))],w-a[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>裴蜀定理</title>
    <url>/2020/05/09/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>定义：ax+by=c成立的充要条件是gcd(a,b)|c,其中，a,b,x,y,c都是整数<br>令s=gcd(a,b)<br>充分条件的证明：</p>
<script type="math/tex; mode=display">
\because a = sp,b = sq\\  
\therefore s|ax,s|by\\
\therefore s|(ax+by)\\
\therefore s|c</script><p>必要条件的证明：</p>
<script type="math/tex; mode=display">
\because gcd(a,b)|c\\
\because a=sp,b=sq,c=sk\\
\therefore 易得spx+sqy=s(px+qy)\\
\because p,q,x,y \in N \therefore px+qy \in N\\
\therefore 必然存在x,y使得px+qy=k存在\\</script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2020/02/17/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>介绍程序设计语言的基本原理和基本实现技术</p>
</blockquote>
<h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><h3 id="什么是编译程序"><a href="#什么是编译程序" class="headerlink" title="什么是编译程序"></a>什么是编译程序</h3><ul>
<li>翻译程序：把某一种语言程序转变成另一种语言程序的过程。</li>
<li>编译程序：把某一种高级语言程序等价的转变成另一种低级语言程序(机器语言或汇编语言)的程序。</li>
<li>分类<ul>
<li>诊断编译程序：帮助程序员开发和调试</li>
<li>优化编译程序：提高目标代码的效率</li>
<li>交叉编译程序：编译和运行和主机并不是同一主机</li>
<li>可变目标编译程序：针对不同平台生成不同程序</li>
</ul>
</li>
<li>解释程序：把源语言作为输入，但不产生目标程序，而是边解释边执行源程序。</li>
</ul>
<h3 id="为什么要学习编译原理"><a href="#为什么要学习编译原理" class="headerlink" title="为什么要学习编译原理"></a>为什么要学习编译原理</h3><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><h3 id="编译程序的结构"><a href="#编译程序的结构" class="headerlink" title="编译程序的结构"></a>编译程序的结构</h3><h3 id="编译程序的生成"><a href="#编译程序的生成" class="headerlink" title="编译程序的生成"></a>编译程序的生成</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树模版</title>
    <url>/2020/05/07/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<ul>
<li>介绍：线段树可以解决区间算术的问题，比如将sum(i,j)转化为sum(i,k)+sum(k,j)</li>
<li>效率：建树O(n),插入log(n),查找log(n)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="comment">//返回p的左儿子节点</span></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">//返回p的右儿子节点</span></span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll p)</span></span>&#123;<span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">//根据初试数组建树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span>;</span><br><span class="line"><span class="comment">//重置树上p节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span>;</span><br><span class="line"><span class="comment">//将节点p的tag下放到ls，rs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p,ll l,ll r)</span></span>;</span><br><span class="line"><span class="comment">//下放的内部代码，提高复用性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ll p,ll l,ll r,ll k)</span></span>;</span><br><span class="line"><span class="comment">//更新代码，从nl到nr加p，注意下放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p,ll k)</span></span>;</span><br><span class="line"><span class="comment">//查询从ql到qr的总和，注意下放</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql,ll qr,ll l,ll r,ll p)</span></span>;</span><br><span class="line"><span class="comment">//树上数组都要开四倍，防止溢出</span></span><br><span class="line">ll n,m,a[N],st[N&lt;&lt;<span class="number">2</span>],tags[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>;i &lt;= n;++i)<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        ll t;<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            ll x,y,k;<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">            update(x,y,<span class="number">1</span>,n,<span class="number">1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ll x,y;<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(x,y,<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll ql,ll qr,ll l,ll r,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; ql || l &gt; qr)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= ql &amp;&amp; r &lt;= qr)&#123;</span><br><span class="line">        <span class="keyword">return</span> st[p];</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (r+l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    push_down(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid)res += query(ql,qr,l,mid,ls(p));</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid)res += query(ql,qr,mid+<span class="number">1</span>,r,rs(p));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ll p,ll l,ll r,ll k)</span></span>&#123;</span><br><span class="line">    tags[p]+=k;</span><br><span class="line">    st[p]+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p,ll l,ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (r+l)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    f(ls(p),l,mid,tags[p]);</span><br><span class="line">    f(rs(p),mid+<span class="number">1</span>,r,tags[p]);</span><br><span class="line">    tags[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line">        st[p]+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">        tags[p]+=k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(p,l,r);</span><br><span class="line">    ll mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl &lt;= mid)update(nl,nr,l,mid,ls(p),k);</span><br><span class="line">    <span class="keyword">if</span>(nr &gt; mid)update(nl,nr,mid+<span class="number">1</span>,r,rs(p),k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span>&#123;</span><br><span class="line">    tags[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        st[p] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(ls(p),l,mid);</span><br><span class="line">    build(rs(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span>&#123;</span><br><span class="line">    st[p] = st[ls(p)]+st[rs(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题总结</title>
    <url>/2020/02/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><strong>问题描述：</strong>有n件物品和容量为m的背包，给出i件物品的重量以及价值，求解让装入背包的物品重量不超过背包容量且价值最大。</p>
<p><strong>无优化思路</strong><br>f[i][j]为前i件物品在j的背包的最大价值<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;=m;c++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][c]=f[i<span class="number">-1</span>][c];</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=w[i])</span><br><span class="line">        f[i][c]=<span class="built_in">max</span>(f[i][c],f[i<span class="number">-1</span>][c-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>一维数组优化</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1048" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=m;c&gt;=w[i];c--)</span><br><span class="line">    <span class="comment">//之所以要从后面开始遍历，是因为更新f[c]要用到f[c-w[i]]</span></span><br><span class="line">    <span class="comment">//也就是说，如果从前面开始遍历，可能后面用到f[c-w[i]]的时候，也用到了</span></span><br><span class="line">   	<span class="comment">//更新后的值，也就是说失去了更新的机会，造成误差。</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[c]=<span class="built_in">max</span>(f[c],f[c-w[i]]+v[i]);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><a href="https://www.luogu.com.cn/problem/P1616" target="_blank" rel="noopener">传送门</a><br>与0-1背包不同，完全背包代表每种物品可以取无限次，但也是0-1背包的变种,正好是一维数组优化的正序。</p>
<p>可以很容易发现，这行代码与0-1背包完全只是改了二维遍历的顺序<br>是这样的，如果从前到后，那么后面的f面对的是已经修改的f，自然是一个完全的做法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=w[i];j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p><a href="https://www.luogu.com.cn/problem/P1776" target="_blank" rel="noopener">传送门</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f[i] 为i空间的价值</span></span><br><span class="line"><span class="comment">// v,w,d分别为价值，重量和数量</span></span><br><span class="line"><span class="comment">// 采用二进制优化，将d[i]件物品分为1,2,4,8等等件块状的物品，分别0-1dp，注意每次的d[i]都要减少对应的1,2,4,8,因为用过了</span></span><br><span class="line"><span class="comment">// 所以最后可能产生剩余，所以加个特判即可</span></span><br><span class="line"><span class="keyword">int</span> n,c,ans = <span class="number">0</span>,x,t,y;<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">rep(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;d[i];</span><br><span class="line">	x = <span class="number">1</span>,t = d[i];</span><br><span class="line">	y = w[i]*x;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=t)&#123;</span><br><span class="line">		drp(j,c,y)&#123;</span><br><span class="line">			f[j] = MAX(f[j],f[j-y]+v[i]*x);</span><br><span class="line">		&#125;</span><br><span class="line">		t -= x;</span><br><span class="line">		x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t)&#123;</span><br><span class="line">		y = w[i]*t;</span><br><span class="line">		drp(j,c,y)&#123;</span><br><span class="line">			f[j] = MAX(f[j],f[j-y]+v[i]*t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><p>转变为0-1背包问题即可解决。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>秘密行动</title>
    <url>/2020/04/04/%E7%A7%98%E5%AF%86%E8%A1%8C%E5%8A%A8/</url>
    <content><![CDATA[<p><a href="http://lx.lanqiao.cn/problem.page?gpid=T581" target="_blank" rel="noopener">原题链接</a><br>描述：n层楼，每层楼高度不一样，可以跳跃或攀爬，前者不消耗时间，跳一层或两层，但无法连续跳，后者需要消耗楼层高度一样的时间。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">	<span class="keyword">int</span> m,n,a[<span class="number">10010</span>],f[<span class="number">10010</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=a[<span class="number">1</span>];<span class="comment">//爬到第一层</span></span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//跳到第一层</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i][<span class="number">0</span>]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>])+a[i];</span><br><span class="line">		f[i][<span class="number">1</span>]=<span class="built_in">min</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-2</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">min</span>(f[m][<span class="number">0</span>],f[m][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何概论</title>
    <url>/2020/05/15/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="基本物理量"><a href="#基本物理量" class="headerlink" title="基本物理量"></a>基本物理量</h2><ul>
<li>点：用(x,y)表示坐标，实际意义为一个点</li>
<li>向量：也用(x,y)表示，但实际意义是一个有方向有长度的量</li>
<li>直线：用一个点和一个向量表示</li>
<li>角度：向量与向量的夹角</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>向量加减：$(a,b)+(x,y)=(a+x,b+y)$; </li>
<li>点乘向量：$p(a,b)=(pa,pb)$</li>
<li>点积：$\vec a \cdot \vec b = |\vec a||\vec b|cos\theta=x1<em>x2+y1</em>y2$</li>
<li>叉积：<script type="math/tex">\vec a \times b = \vec c,|\vec c|=|\vec a||\vec b|sin\theta</script><a href="https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A7%AF/4601007?fromtitle=%E5%8F%89%E7%A7%AF&amp;fromid=2812058&amp;fr=aladdin" target="_blank" rel="noopener">叉积</a></li>
<li>旋转：<script type="math/tex; mode=display">
分解\vec a =  x*(1,0)+y*(0,1)\\
旋转\theta 时\\
\vec a = x*(cos\theta,sin\theta)+y*(-sin\theta,cos\theta)\\</script></li>
</ul>
<h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><ul>
<li>最小圆覆盖：用最小的圆覆盖平面中的所有点</li>
<li>凸包：凸包就是把给定点包围在内部，面积最小的凸多边形</li>
<li>半平面交：指多个半平面的交集。</li>
<li>旋转卡壳：求凸包上最远点对的距离等等。</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/clover_hxy/article/details/53966405" target="_blank" rel="noopener">计算几何总结</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>调度算法总结</title>
    <url>/2020/06/17/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>调度算法是操作系统调度处理器的算法，而系统分配资源的基本单位是进程，所以一般而言调度算法指的就是进程调度，但是在批处理系统中，调度算法也可以指作业调度</p>
<h2 id="先来先服务算法FIFS"><a href="#先来先服务算法FIFS" class="headerlink" title="先来先服务算法FIFS"></a>先来先服务算法FIFS</h2><ul>
<li>基本思想：按照进程进入就绪队列的先后次序分配处理器</li>
<li>特点：<ul>
<li>利于长进程，不利于短进程，因为长进程等待的时间更短</li>
<li>对于分时系统和实时系统是致命的，因为这两种系统都要求很快的交互速度，尤其是实时系统</li>
<li>常常不单独使用，而是结合其他系统一起使用，比如优先级调度算法中，如果优先级一致，那么先来先服务</li>
</ul>
</li>
</ul>
<h2 id="短作业优先调度算法SJF"><a href="#短作业优先调度算法SJF" class="headerlink" title="短作业优先调度算法SJF"></a>短作业优先调度算法SJF</h2><ul>
<li>基本思想：把处理器分配给最快完成的作业或进程</li>
<li>特点<ul>
<li>在所有作业同时到达时，SJF的平均周转时间最短</li>
<li>但是对长进程不利，很可能出现”饥饿”或者”饿死现象”</li>
</ul>
</li>
</ul>
<h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><ul>
<li>基本思想：</li>
</ul>
<h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>进制间转换</title>
    <url>/2020/02/10/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>定义：进制间转换指一个数从x进制转换到y进制，可以先把x进制转换为十进制，再把十进制转换为y进制。</p>
<p>一、从x进制到十进制的转换<br><strong>按位累加</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,ans = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">	ans = ans*x + arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>二、从十进制到y进制的转换<br><strong>取余数除以基数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in转为y进制</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> in,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span>(in)&#123;</span><br><span class="line">		<span class="comment">// in = mod*k + yu</span></span><br><span class="line">		<span class="comment">// yu = in%y</span></span><br><span class="line">		<span class="comment">// 想象in是一个y进制数，例如3进制</span></span><br><span class="line">		<span class="comment">// 21021</span></span><br><span class="line">		<span class="comment">// 那么除了个位，其他位都可以被3整除，先求个位，就是取余了</span></span><br><span class="line">		<span class="comment">// 然后需要求出其他位数，去掉个位，其他右移，如下</span></span><br><span class="line">		<span class="comment">// 1. in = in - yu</span></span><br><span class="line">		<span class="comment">// 2. in = 21020 = 2102 * 3</span></span><br><span class="line">		<span class="comment">// 所以了，直接除3就是了</span></span><br><span class="line">		res = (<span class="keyword">char</span>)(in%y+<span class="string">'0'</span>)+res;</span><br><span class="line">		in/=y;	<span class="comment">//这里的除法可以理解为</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别地，二进制的余数只有0和1，就不用取余，而是求奇偶得到</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>链式向前星</title>
    <url>/2020/05/01/%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F/</url>
    <content><![CDATA[<p>链式向前星是一种极其节省空间的存图的方法，而且易访问<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> to[N],nxt[N],head[N];</span><br><span class="line"><span class="comment">//如代码所示</span></span><br><span class="line"><span class="comment">//to[i]代表第i条边的末端点，nxt[i]代表连接源点a的下一条边，head[i]代表i为源点的最后一条边的poi</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    to[++cur]=b;</span><br><span class="line">    nxt[cur]=head[a];</span><br><span class="line">    head[a]=cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    nxt[cnt] = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的位运算</title>
    <url>/2020/05/22/%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>^,&amp;,|,&lt;&lt;,&gt;&gt;</p>
<ul>
<li>x&amp;(-x)：求低位第一个1</li>
<li>x&amp;(x-1)：求去掉低位第一个一之后的数</li>
<li>x^1:如果x是奇数，减一，偶数，加一</li>
<li>x&amp;~(1&lt;&lt;i)：x去掉第i个二进制的1</li>
</ul>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2020/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="计算机的概念与类型"><a href="#计算机的概念与类型" class="headerlink" title="计算机的概念与类型"></a>计算机的概念与类型</h3><ul>
<li>定义：是一种可以存储程序，并且通过执行程序指令，可以自动、高速、精确地对数字信息进行各种复杂处理，然后输出运算结果的高科技智能电子设备。</li>
<li>五个逻辑模块：输入设备，存储器，输出设备，运算器，控制器<br><img src="计算机运行逻辑图.png" alt=""></li>
<li>信息的数字化表示<ul>
<li>在计算机中用数字代码表示各种信息</li>
<li>在物理机制上用数字信号表示数字代码</li>
<li>信息数字化表示的优点<br>  （1）物理上易实现信息的表示与存储<br>  （2）抗干扰能力强，可靠性高<br>  （3）数值的表示范围大，精度高<br>  （4）可表示的信息类型广泛<br>  （5）能用数字逻辑技术进行处理</li>
</ul>
</li>
<li>存储程序工作方式<ol>
<li>编制程序</li>
<li>存储程序</li>
<li>自动、连续执行程序</li>
<li>输出结果</li>
</ol>
</li>
<li>计算机的分类，主要分为模拟计算机和数字计算机 <ul>
<li>模拟计算机：由模拟运算器件构成，处理在时间和数值上连续的模拟量（如：电压、电流等）；</li>
<li>数字计算机：由数字逻辑器件构成，处理离散的数字量。</li>
</ul>
</li>
</ul>
<h3 id="计算机的诞生与发展"><a href="#计算机的诞生与发展" class="headerlink" title="计算机的诞生与发展"></a>计算机的诞生与发展</h3><h3 id="计算机系统的层次"><a href="#计算机系统的层次" class="headerlink" title="计算机系统的层次"></a>计算机系统的层次</h3><h3 id="计算机的性能评价"><a href="#计算机的性能评价" class="headerlink" title="计算机的性能评价"></a>计算机的性能评价</h3>]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>采药</title>
    <url>/2020/02/11/%E9%87%87%E8%8D%AF/</url>
    <content><![CDATA[<p><strong>原题链接：</strong>[传送门][<a href="https://www.luogu.com.cn/problem/P1048" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1048</a>]</p>
<p><strong>描述：</strong>时间T内，M种药，每种药需要不同的时间，并含有不同的价值，问能获得的最大价值是多少？</p>
<p><strong>思路：</strong>简单的tp问题，作一个dp[M][T]数组，表示T时间内前M的药物能获得的最大价值，然后递增即可。</p>
<p><strong>传递方程：</strong>dp[i][j] = max(dp[i - 1][j - a[i]] + b[i],dp[i - 1][j]);</p>
<p><strong>代码：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt; y ? y : x;&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>],b[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;,T,M;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;T,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;++i) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">    a[<span class="number">0</span>] = b[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= M;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= T;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= a[i])</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - a[i]] + b[i],dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[M][T]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2020/02/09/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p><strong>描述：</strong>给定一个数字序列，求满足i &lt; j &amp;&amp; arr[i] &gt; arr[j]的个数</p>
<p><strong>原题链接：</strong><a href="https://www.luogu.com.cn/problem/P1908" target="_blank" rel="noopener">传送门</a></p>
<p><strong>思路：</strong>使用归并排序，根据排序原理，排序中间添加一行计数器代码，每次当左边数组的数字大于右边数组的数字的时候，说明左边数组存在m - i + 1个数(i往右边数直到中数m)大于右边数组的数，那么计数器加上m-i+1，最后计数器的数就是答案。</p>
<p><strong>代码：</strong></p>
<blockquote>
<p>复杂度为O(nlogn)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn],t[maxn]; </span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">		<span class="keyword">int</span> m = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">		msort(l,m);</span><br><span class="line">		msort(m+<span class="number">1</span>,r);</span><br><span class="line">		merge(l,r,m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = l,j = m + <span class="number">1</span>,id = l;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">			t[id++] = arr[i++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ans += (ll)m - i + <span class="number">1</span>;</span><br><span class="line">			t[id++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= m) t[id++] = arr[i++];</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= r) t[id++] = arr[j++];</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r) arr[l] = t[l],++l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p = <span class="number">0</span>,flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c = getchar();</span><br><span class="line">	<span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) flag = <span class="number">-1</span>;c = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) p = p*<span class="number">10</span> + c - <span class="string">'0'</span>,c = getchar();</span><br><span class="line">	<span class="keyword">return</span> p*flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)arr[i] = <span class="built_in">read</span>();</span><br><span class="line">	msort(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络概述-上"><a href="#计算机网络概述-上" class="headerlink" title="计算机网络概述(上)"></a>计算机网络概述(上)</h2><h3 id="计算机网络基本概念"><a href="#计算机网络基本概念" class="headerlink" title="计算机网络基本概念"></a>计算机网络基本概念</h3><ul>
<li>定义：计算机网络是<strong>通信技术</strong>和<strong>计算机技术</strong>精密结合的产物</li>
<li>通信系统模型：</li>
<li>计算机网络就是一种通信网络</li>
</ul>
<h4 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h4><p>精确定义：计算机网络就是<strong>互连</strong>的、<strong>自治</strong>的计算机集合</p>
<ul>
<li>自治-无主从关系</li>
<li>互连-互连互通、通信链路(光纤、电缆等设备)</li>
<li>距离远、数量大如何保证互连?</li>
<li>通过交换网络互连主机(交换节点：路由器或交换机)</li>
</ul>
<h4 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h4><p>ISP，网络互连的“网络之网络”</p>
<ul>
<li>从组成细节角度<ul>
<li>计算设备集合<ul>
<li>主机(hosts)=端系统(end systems)</li>
<li>运行各种网络应用</li>
</ul>
</li>
<li>通信链路<ul>
<li>光纤, 铜缆, 无线电,卫星……</li>
</ul>
</li>
<li>分组交换: 转发分组(数据包)<ul>
<li>路由器(routers)和交换机(switches)</li>
</ul>
</li>
<li>仅有硬件就够了吗<ul>
<li>不，还需要协议</li>
</ul>
</li>
</ul>
</li>
<li>从服务角度<ul>
<li>为网路应用提供通信服务的通信基础设施</li>
<li>为网络应用提供应用编程接口(API)</li>
</ul>
</li>
</ul>
<h4 id="什么是网络协议"><a href="#什么是网络协议" class="headerlink" title="什么是网络协议"></a>什么是网络协议</h4><ul>
<li>定义：网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定</li>
<li>协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”（actions）</li>
<li>协议三要素<ul>
<li>语法（Systax)<ul>
<li>数据与控制信息的结构或格式</li>
<li>信号电平</li>
</ul>
</li>
<li>语义(Semantics)<ul>
<li>需要发出何种控制信息</li>
<li>完成何种动作以及作出何种响应</li>
<li>差错控制</li>
</ul>
</li>
<li>时序(Timing)<ul>
<li>事件顺序</li>
<li>速度匹配</li>
</ul>
</li>
</ul>
</li>
<li>协议规范了网络中所有信息发送和接收过程<ul>
<li>TCP,IP,HTTP,Skype,802.11</li>
</ul>
</li>
<li>Internet协议标准<ul>
<li>RFC: Request for Comments</li>
<li>IETF:互联网工程任务组（Internet Engineering TaskForce）</li>
</ul>
</li>
</ul>
<h3 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h3><ul>
<li>网络边缘<ul>
<li>主机</li>
<li>网络应用</li>
</ul>
</li>
<li>接入网络，物理介质<ul>
<li>有线或无线通信链路</li>
</ul>
</li>
<li>网络核心<ul>
<li>互联的路由器网络</li>
<li>关键功能<ul>
<li>路由(routing):确定分组从源到目的传输路径</li>
<li>转发(forwarding):将分组从路由器的输入端口交换至正确的输出端口</li>
</ul>
</li>
</ul>
</li>
<li>如何接入网络<ul>
<li>数字用户线路 (DSL)</li>
<li>电缆网络</li>
<li>机构（企业）接入网络 (Ethernet</li>
<li>无线接入网络<ul>
<li>无线局域网（LANs）</li>
<li>广域无线接入</li>
</ul>
</li>
</ul>
</li>
<li>如何实现数据从源主机通过网络核心送达目的主机？        <ul>
<li>数据交换</li>
</ul>
</li>
</ul>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><h4 id="数据交换-电路交换"><a href="#数据交换-电路交换" class="headerlink" title="数据交换-电路交换"></a>数据交换-电路交换</h4><ul>
<li>描述：两个端设备通过电路和中继线和交换机进行数据交换</li>
<li>特点：独占资源</li>
<li>三个阶段：<ul>
<li>建立连接</li>
<li>通信</li>
<li>释放连接</li>
</ul>
</li>
<li>中继线组成了电话交换网络<ul>
<li>动态分配传输资源</li>
<li>可以多路复用</li>
</ul>
</li>
</ul>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><ul>
<li>描述：链路划分位资源片，每片分配给各路呼叫，没路呼叫独占分配道德资源，资源片可能闲置。</li>
<li>典型多路复用方法<ul>
<li>频分多路复用FDM<ul>
<li>信道资源在频率上进行划分，如有线电视网络</li>
<li>每个用户占用不同的频带</li>
</ul>
</li>
<li>时分多路复用TDM<ul>
<li>将时间划分为一段段等长的时分复用帧</li>
<li>每个用户在每个TDM帧种占用固定序号的时隙</li>
<li>每个用户占用的时隙是周期性出现（其周期就是TDM帧的长度）</li>
</ul>
</li>
<li>波分多路复用WDM<ul>
<li>是光的频分复用</li>
<li>将光在不同频率上进行划分</li>
</ul>
</li>
<li>码分多路复用CDM<ul>
<li>广泛用于无限链路共享(如蜂窝网，卫星通信等)</li>
<li>为每个用户分配一个唯一的m bit码片序列，用+1，-1表示</li>
<li>每个用户使用相同频率载波，利用各自码片序列编码数据</li>
<li>编码信号=(原始数据)*(码片序列)</li>
<li>各用户码片序列相互正交</li>
<li>接受时，得到的是所有数据，所以需要解码</li>
<li>解码：码片序列与编码信号的内积</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><p>存储接受到的报文，判断其目标地址以选择路由，最后，在下一跳路由空闲时，将数据转发给下一跳路由。报文交换系统现今都由分组交换或电路交换网络所承载。</p>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ul>
<li>拆分报文成多个小数据包，数据包会加上头部，其中含有地址等信息。</li>
<li>分组交换需要报文的拆分与重组</li>
<li>产生额外开销因为是在源主机和目的主机中，所以负载也不会很大。</li>
<li><strong>统计多路复用</strong>：按需共享链路</li>
</ul>
<h4 id="报文交换和分组交换的对比"><a href="#报文交换和分组交换的对比" class="headerlink" title="报文交换和分组交换的对比"></a>报文交换和分组交换的对比</h4><ul>
<li>报文交换和分组交换都是采用存储-转发方式</li>
<li>但分组交换需要的时间小于报文交换，这是因为采用了并行的方式，使得每个路由节点在同一时间都在运行。</li>
<li>分组交换优缺点：<ul>
<li>适用于突发性网络传输（例浏览网页等）</li>
<li>可能产生拥塞：分组延迟或丢失    </li>
</ul>
</li>
</ul>
<h2 id="计算机网络概述-下"><a href="#计算机网络概述-下" class="headerlink" title="计算机网络概述(下)"></a>计算机网络概述(下)</h2><h3 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><ul>
<li>定义：速率即数据率(data rate)或称数据传输速率或比特率(bit rate)</li>
<li>速率往往是指额定速率或标称速率</li>
</ul>
<h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><ul>
<li>“带宽”(bandwidth)原本指信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）</li>
<li>网络的“带宽”通常是数字信道所能传送的“最高数据率”，单位：b/s (bps)</li>
</ul>
<h4 id="延迟-时延-delay或latency"><a href="#延迟-时延-delay或latency" class="headerlink" title="延迟/时延(delay或latency)"></a>延迟/时延(delay或latency)</h4><ul>
<li>结点处理延迟：差错检测、确定输出链路、通常&lt; msec</li>
<li>排队延迟：等待输出链路可用、取决于路由器拥塞程度<ul>
<li>R: 链路带宽(bps)</li>
<li>L: 分组长度 (bits)</li>
<li>a: 平均分组到达速率</li>
<li>流量强度（traffic intensity）= La/R<ul>
<li>La/R ~ 0: 平均排队延迟很小</li>
<li>La/R -&gt; 1: 平均排队延迟很大</li>
<li>La/R &gt; 1: 超出服务能力，平均排队延迟无限大！</li>
</ul>
</li>
</ul>
</li>
<li>传输延迟：L: 分组长度(bits)、R: 链路带宽 (bps)、dtrans = L/R</li>
<li>传播延迟：d: 物理链路长度、s: 信号传播速度 (~2×108m/sec)、dprop = d/s</li>
</ul>
<h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><ul>
<li>时延带宽积 = 传播时延 * 带宽 = ddrop*R</li>
<li>链路的时延带宽积又称为以比特为单位的链路长度</li>
</ul>
<h4 id="分组丢失（丢包）"><a href="#分组丢失（丢包）" class="headerlink" title="分组丢失（丢包）"></a>分组丢失（丢包）</h4><ul>
<li>队列缓存容量有限</li>
<li>分组到达已满队列将被丢弃 (即丢包)</li>
<li>丢弃分组可能由前序结点或源重发（也可能不重发）</li>
<li>丢包率= 已发分组总数/丢包数</li>
</ul>
<h4 id="吞吐量-率（Throughput）"><a href="#吞吐量-率（Throughput）" class="headerlink" title="吞吐量/率（Throughput）"></a>吞吐量/率（Throughput）</h4><ul>
<li>吞吐量:表示在发送端与接收端之间传送数<br>据速率 (b/s)</li>
<li>即时吞吐量: 给定时刻的速率</li>
<li>平均吞吐量: 一段时间的平均速率</li>
<li>一般吞吐量都是有较低传送速率的一端决定</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><ul>
<li>定义：计算机网络体系结构简称网络体系结构(network architecture)是分层结构，计算机网络体系结构是计算机网络的各层及其协议的集合</li>
<li>分层结构的优点：<ul>
<li>结构清晰</li>
<li>易于更新维护</li>
<li>利于标准化</li>
</ul>
</li>
<li>基本概念<ul>
<li>协议是控制两个对等实体进行通信的规则的集合，协议是“水平的”。</li>
<li>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的”。</li>
<li>下层协议的实现对上层的服务用户是透明的。</li>
<li>同系统的相邻层实体间通过接口进行交互，通过服务访问点 SAP(Service Access Point)，交换原语，指定请求的特定服务。</li>
</ul>
</li>
</ul>
<h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><ul>
<li>介绍：开放系统互连 (OSI)参考模型是由国际标准化组织 (ISO) 于1984年提出的分层网络体系结构模型，有7层，理论成功，实践失败</li>
<li>参考模型解释的通信过程<br><img src="OSI参考模型.png" alt=""></li>
<li><p>为什么要数据封装</p>
<ul>
<li>增加控制信息<ul>
<li>构造协议数据单元 (PDU)</li>
</ul>
</li>
<li>控制信息主要包括:<ul>
<li>地址（Address）: 标识发送端/接收端</li>
<li>差错检测编码（Error-detecting code）: 用于差错检测或纠正</li>
<li>协议控制（Protocol control）: 实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS）、 和安全控制等</li>
</ul>
</li>
</ul>
</li>
<li><p>物理层功能：传输比特级的编码</p>
</li>
<li>数据链路层：<ul>
<li>负责结点-结点（node-to-node）数据传输</li>
<li>组帧（Framing）</li>
<li>物理寻址（Physical addressing）<ul>
<li>在帧头中增加发送端和/或接收端的物理地址标识数据帧的发送端和/或接收端</li>
</ul>
</li>
<li>流量控制（Flow control）<ul>
<li>避免淹没接收端</li>
</ul>
</li>
<li>差错控制（Error control）<ul>
<li>检测并重传损坏或丢失帧，并避免重复帧</li>
</ul>
</li>
<li>访问(接入)控制（Access control）<ul>
<li>在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权</li>
</ul>
</li>
</ul>
</li>
<li>网络层功能<ul>
<li>负责源主机到目的主机数据分组（packet）交付<ul>
<li>可能穿越多个网络</li>
</ul>
</li>
<li>逻辑寻址（Logical addressing）<ul>
<li>全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址</li>
</ul>
</li>
<li>路由（Routing）<ul>
<li>路由器(或网关)互连网络，并路由分组至最终目的主机</li>
<li>路径选择</li>
</ul>
</li>
<li>分组转发</li>
</ul>
</li>
<li>传输层功能：进程-进程的数据传输</li>
<li>应用层: 支持各种网络应用</li>
</ul>
<h2 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="应用层大纲.png" alt=""></p>
<h3 id="网络应用的基本原理"><a href="#网络应用的基本原理" class="headerlink" title="网络应用的基本原理"></a>网络应用的基本原理</h3><h4 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h4><ul>
<li>客户机/服务器结构(Client-Server, C/S)</li>
<li>点对点结构(Peer-to-peer, P2P)</li>
<li>混合结构(Hybrid)</li>
</ul>
<h4 id="网络应用进程通信"><a href="#网络应用进程通信" class="headerlink" title="网络应用进程通信"></a>网络应用进程通信</h4><ul>
<li>网络应用的基础：进程间通信<ul>
<li>同一主机上：操作系统提供支持</li>
<li>不同主机上：报文交换，或者消息交换。</li>
</ul>
</li>
<li>套接字<ul>
<li>进程间通信利用socket发送/接收消息实现</li>
</ul>
</li>
<li>应用层协议<ul>
<li>公开协议<ul>
<li>由RFC(Request For Comments)定义</li>
<li>允许互操作</li>
<li>HTTP, SMTP, ……</li>
</ul>
</li>
<li>私有协议<ul>
<li>多数P2P文件共享应用</li>
</ul>
</li>
</ul>
</li>
<li>应用层协议的内容<ul>
<li>消息的类型(type)<ul>
<li>请求消息</li>
<li>响应消息</li>
</ul>
</li>
<li>消息的语法(syntax)/格式<ul>
<li>消息中有哪些字段(field)？</li>
<li>每个字段如何描述</li>
</ul>
</li>
<li>字段的语义(semantics)<ul>
<li>字段中信息的含义</li>
</ul>
</li>
<li>规则(rules)<ul>
<li>进程何时发送/响应消息</li>
<li>进程如何发送/响应消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="网络应用的需求与传输层服务"><a href="#网络应用的需求与传输层服务" class="headerlink" title="网络应用的需求与传输层服务"></a>网络应用的需求与传输层服务</h4><ul>
<li>网络应用对传输服务的需求</li>
<li>数据丢失(data loss)/可靠性(reliability)<ul>
<li>某些网络应用能够容忍一定的数据丢失：网络电话</li>
<li>某些网络应用要求100%可靠的数据传输：文件传输，telnet</li>
</ul>
</li>
<li>时间(timing)/延迟(delay)<ul>
<li>有些应用只有在延迟足够低时才“有效”</li>
<li>网络电话/网络游戏</li>
</ul>
</li>
<li>带宽(bandwidth)<ul>
<li>某些应用只有在带宽达到最低要求时才“有效”：网络视频</li>
<li>某些应用能够适应任何带宽——弹性应用：email</li>
</ul>
</li>
<li>Internet提供的传输服务<ul>
<li>TCP服务<ul>
<li>面向连接: 客户机/服务器进程间需要建立连接</li>
<li>可靠的传输</li>
<li>流量控制: 发送方不会发送速度过快，超过接收方的处理能力</li>
<li>拥塞控制: 当网络负载过重时能够限制发送方的发送速度</li>
<li>不提供时间/延迟保障</li>
<li>不提供最小带宽保障</li>
</ul>
</li>
<li>UDP服务<ul>
<li>无连接</li>
<li>不可靠的数据传输</li>
<li>不提供：</li>
<li>可靠性保障</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>延迟保障</li>
<li>带宽保障</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><h3 id="Email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h3><h3 id="DNS应用"><a href="#DNS应用" class="headerlink" title="DNS应用"></a>DNS应用</h3>]]></content>
      <categories>
        <category>计算机课</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>麦森数</title>
    <url>/2020/02/11/%E9%BA%A6%E6%A3%AE%E6%95%B0/</url>
    <content><![CDATA[<p>原题链接：<a href="https://www.luogu.com.cn/problem/P1045" target="_blank" rel="noopener">传送门</a></p>
<p>描述：给定一个数P，求2^p-1的位数和后500位数字，不足500位前面补零。</p>
<p>思路：<br>前一问，直接换成10的底，位数 = log(2)*p+1<br>后一问，采用快速幂算法，把指数p想象成二进制数字10101…，2^p = 2^(2^j)*2^(2^k)…</p>
<p>代码：<br>```c++</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
int ans[1005],f[1005],tmp[1005];
//用于计算二进制P奇数位时的乘法运算
void f1(){
    memset(tmp,0,sizeof(tmp));
    for(int i = 1;i &lt;= 500;++i){
        for(int j = 1;j &lt;= 500;++j){
            tmp[i + j - 1] += ans[i] * f[j];//直接计算某位上的值，随后进行进位
        }
    }
    for(int i = 1;i &lt;= 500;++i){
        tmp[i + 1] += tmp[i] / 10;
        tmp[i] %= 10;
    }
    memcpy(ans,tmp,sizeof(tmp));
}
//用于每次对f的更新
void f2(){
    memset(tmp,0,sizeof(tmp));
    for(int i = 1;i &lt;= 500;++i){
        for(int j = 1;j &lt;= 500;++j){
            tmp[i + j - 1] += f[i] * f[j];
        }
    }
    for(int i = 1;i &lt;= 500;++i){
        tmp[i + 1] += tmp[i] / 10;
        tmp[i] %= 10;
    }
    memcpy(f,tmp,sizeof(tmp));
}
int main(){
    int p;
    scanf(&quot;%d&quot;,&amp;p);
    printf(&quot;%d\n&quot;,(int)(log10(2)*p+1));
    f[1] = 2,ans[1]  = 1;
    //核心快速幂代码
    while(p){
        if(p&amp;1) f1();//计算末位
        p &gt;&gt;= 1;
        f2();//更新乘数2^k
    }
    ans[1]-=1;
    for(int i = 500;i &gt;= 1;--i){
        if(i % 50 == 0 &amp;&amp; i != 500)putchar(&#39;\n&#39;);
        printf(&quot;%d&quot;,ans[i]);
    }
    return 0;
}
</code></pre>]]></content>
      <categories>
        <category>题</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>I MISS U</title>
    <url>/2020/09/29/I-MISS-U/</url>
    <content><![CDATA[<h1 id="I-MISS-U"><a href="#I-MISS-U" class="headerlink" title="I MISS U"></a>I MISS U</h1><p>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U<br>I-MISS-U</p>
]]></content>
  </entry>
</search>
